{"version":3,"file":"InputPassword-we-1llkp.js","sources":["../../src/hooks/web/useConfigGlobal.ts","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/helper.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/data/dateSplits.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/data/const.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/date/matching.esm.js","../../node_modules/.pnpm/fastest-levenshtein@1.0.16/node_modules/fastest-levenshtein/esm/mod.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/levenshtein.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/data/l33tTable.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/data/translationKeys.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/variants/matching/unmunger/TrieNode.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/variants/matching/unmunger/l33tTableToTrieNode.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/Options.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/variants/matching/reverse.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/variants/matching/unmunger/getCleanPasswords.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/variants/matching/l33t.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/matching.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/regex/matching.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/scoring/utils.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/bruteforce/scoring.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/date/scoring.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/variants/scoring/uppercase.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/variants/scoring/l33t.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/scoring.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/regex/scoring.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/repeat/scoring.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/sequence/scoring.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/spatial/scoring.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/separator/scoring.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/scoring/estimate.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/scoring/index.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/repeat/matching.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/sequence/matching.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/spatial/matching.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/separator/matching.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/Matching.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/TimeEstimates.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/bruteforce/feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/date/feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/dictionary/feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/regex/feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/repeat/feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/sequence/feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/spatial/feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/matcher/separator/feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/Feedback.esm.js","../../node_modules/.pnpm/@zxcvbn-ts+core@3.0.4/node_modules/@zxcvbn-ts/core/dist/index.esm.js","../../src/components/InputPassword/src/InputPassword.vue"],"sourcesContent":["import { ConfigGlobalTypes } from '@/components/ConfigGlobal'\nimport { inject } from 'vue'\n\nexport const useConfigGlobal = () => {\n  const configGlobal = inject('configGlobal', {}) as ConfigGlobalTypes\n\n  return {\n    configGlobal\n  }\n}\n","const extend = (listToExtend, list) =>\n// eslint-disable-next-line prefer-spread\nlistToExtend.push.apply(listToExtend, list);\n// sort on i primary, j secondary\nconst sorted = matches => matches.sort((m1, m2) => m1.i - m2.i || m1.j - m2.j);\nconst buildRankedDictionary = orderedList => {\n  const result = {};\n  let counter = 1; // rank starts at 1, not 0\n  orderedList.forEach(word => {\n    result[word] = counter;\n    counter += 1;\n  });\n  return result;\n};\n\nexport { buildRankedDictionary, extend, sorted };\n//# sourceMappingURL=helper.esm.js.map\n","var dateSplits = {\n  4: [\n  // for length-4 strings, eg 1191 or 9111, two ways to split:\n  [1, 2], [2, 3] // 91 1 1\n  ],\n\n  5: [[1, 3], [2, 3],\n  //  [2, 3], // 91 1 11    <- duplicate previous one\n  [2, 4] // 91 11 1    <- New and must be added as bug fix\n  ],\n\n  6: [[1, 2], [2, 4], [4, 5] // 1991 1 1\n  ],\n\n  //  1111991\n  7: [[1, 3], [2, 3], [4, 5], [4, 6] // 1991 11 1\n  ],\n\n  8: [[2, 4], [4, 6] // 1991 11 11\n  ]\n};\n\nexport { dateSplits as default };\n//# sourceMappingURL=dateSplits.esm.js.map\n","import dateSplits from './dateSplits.esm.js';\n\nconst DATE_MAX_YEAR = 2050;\nconst DATE_MIN_YEAR = 1000;\nconst DATE_SPLITS = dateSplits;\nconst BRUTEFORCE_CARDINALITY = 10;\nconst MIN_GUESSES_BEFORE_GROWING_SEQUENCE = 10000;\nconst MIN_SUBMATCH_GUESSES_SINGLE_CHAR = 10;\nconst MIN_SUBMATCH_GUESSES_MULTI_CHAR = 50;\nconst MIN_YEAR_SPACE = 20;\n// \\xbf-\\xdf is a range for almost all special uppercase letter like Ä and so on\nconst START_UPPER = /^[A-Z\\xbf-\\xdf][^A-Z\\xbf-\\xdf]+$/;\nconst END_UPPER = /^[^A-Z\\xbf-\\xdf]+[A-Z\\xbf-\\xdf]$/;\n// \\xdf-\\xff is a range for almost all special lowercase letter like ä and so on\nconst ALL_UPPER = /^[A-Z\\xbf-\\xdf]+$/;\nconst ALL_UPPER_INVERTED = /^[^a-z\\xdf-\\xff]+$/;\nconst ALL_LOWER = /^[a-z\\xdf-\\xff]+$/;\nconst ALL_LOWER_INVERTED = /^[^A-Z\\xbf-\\xdf]+$/;\nconst ONE_LOWER = /[a-z\\xdf-\\xff]/;\nconst ONE_UPPER = /[A-Z\\xbf-\\xdf]/;\nconst ALPHA_INVERTED = /[^A-Za-z\\xbf-\\xdf]/gi;\nconst ALL_DIGIT = /^\\d+$/;\nconst REFERENCE_YEAR = new Date().getFullYear();\nconst REGEXEN = {\n  recentYear: /19\\d\\d|200\\d|201\\d|202\\d/g\n};\n/* Separators */\nconst SEPERATOR_CHARS = [' ', ',', ';', ':', '|', '/', '\\\\', '_', '.', '-'];\nconst SEPERATOR_CHAR_COUNT = SEPERATOR_CHARS.length;\n\nexport { ALL_DIGIT, ALL_LOWER, ALL_LOWER_INVERTED, ALL_UPPER, ALL_UPPER_INVERTED, ALPHA_INVERTED, BRUTEFORCE_CARDINALITY, DATE_MAX_YEAR, DATE_MIN_YEAR, DATE_SPLITS, END_UPPER, MIN_GUESSES_BEFORE_GROWING_SEQUENCE, MIN_SUBMATCH_GUESSES_MULTI_CHAR, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, MIN_YEAR_SPACE, ONE_LOWER, ONE_UPPER, REFERENCE_YEAR, REGEXEN, SEPERATOR_CHARS, SEPERATOR_CHAR_COUNT, START_UPPER };\n//# sourceMappingURL=const.esm.js.map\n","import { DATE_MIN_YEAR, DATE_MAX_YEAR, REFERENCE_YEAR, DATE_SPLITS } from '../../data/const.esm.js';\nimport { sorted } from '../../helper.esm.js';\n\n/*\n * -------------------------------------------------------------------------------\n *  date matching ----------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchDate {\n  /*\n   * a \"date\" is recognized as:\n   *   any 3-tuple that starts or ends with a 2- or 4-digit year,\n   *   with 2 or 0 separator chars (1.1.91 or 1191),\n   *   maybe zero-padded (01-01-91 vs 1-1-91),\n   *   a month between 1 and 12,\n   *   a day between 1 and 31.\n   *\n   * note: this isn't true date parsing in that \"feb 31st\" is allowed,\n   * this doesn't check for leap years, etc.\n   *\n   * recipe:\n   * start with regex to find maybe-dates, then attempt to map the integers\n   * onto month-day-year to filter the maybe-dates into dates.\n   * finally, remove matches that are substrings of other matches to reduce noise.\n   *\n   * note: instead of using a lazy or greedy regex to find many dates over the full string,\n   * this uses a ^...$ regex against every substring of the password -- less performant but leads\n   * to every possible date match.\n   */\n  match({\n    password\n  }) {\n    const matches = [...this.getMatchesWithoutSeparator(password), ...this.getMatchesWithSeparator(password)];\n    const filteredMatches = this.filterNoise(matches);\n    return sorted(filteredMatches);\n  }\n  getMatchesWithSeparator(password) {\n    const matches = [];\n    const maybeDateWithSeparator = /^(\\d{1,4})([\\s/\\\\_.-])(\\d{1,2})\\2(\\d{1,4})$/;\n    // # dates with separators are between length 6 '1/1/91' and 10 '11/11/1991'\n    for (let i = 0; i <= Math.abs(password.length - 6); i += 1) {\n      for (let j = i + 5; j <= i + 9; j += 1) {\n        if (j >= password.length) {\n          break;\n        }\n        const token = password.slice(i, +j + 1 || 9e9);\n        const regexMatch = maybeDateWithSeparator.exec(token);\n        if (regexMatch != null) {\n          const dmy = this.mapIntegersToDayMonthYear([parseInt(regexMatch[1], 10), parseInt(regexMatch[3], 10), parseInt(regexMatch[4], 10)]);\n          if (dmy != null) {\n            matches.push({\n              pattern: 'date',\n              token,\n              i,\n              j,\n              separator: regexMatch[2],\n              year: dmy.year,\n              month: dmy.month,\n              day: dmy.day\n            });\n          }\n        }\n      }\n    }\n    return matches;\n  }\n  // eslint-disable-next-line max-statements\n  getMatchesWithoutSeparator(password) {\n    const matches = [];\n    const maybeDateNoSeparator = /^\\d{4,8}$/;\n    const metric = candidate => Math.abs(candidate.year - REFERENCE_YEAR);\n    // # dates without separators are between length 4 '1191' and 8 '11111991'\n    for (let i = 0; i <= Math.abs(password.length - 4); i += 1) {\n      for (let j = i + 3; j <= i + 7; j += 1) {\n        if (j >= password.length) {\n          break;\n        }\n        const token = password.slice(i, +j + 1 || 9e9);\n        if (maybeDateNoSeparator.exec(token)) {\n          const candidates = [];\n          const index = token.length;\n          const splittedDates = DATE_SPLITS[index];\n          splittedDates.forEach(([k, l]) => {\n            const dmy = this.mapIntegersToDayMonthYear([parseInt(token.slice(0, k), 10), parseInt(token.slice(k, l), 10), parseInt(token.slice(l), 10)]);\n            if (dmy != null) {\n              candidates.push(dmy);\n            }\n          });\n          if (candidates.length > 0) {\n            /*\n             * at this point: different possible dmy mappings for the same i,j substring.\n             * match the candidate date that likely takes the fewest guesses: a year closest\n             * to 2000.\n             * (scoring.REFERENCE_YEAR).\n             *\n             * ie, considering '111504', prefer 11-15-04 to 1-1-1504\n             * (interpreting '04' as 2004)\n             */\n            let bestCandidate = candidates[0];\n            let minDistance = metric(candidates[0]);\n            candidates.slice(1).forEach(candidate => {\n              const distance = metric(candidate);\n              if (distance < minDistance) {\n                bestCandidate = candidate;\n                minDistance = distance;\n              }\n            });\n            matches.push({\n              pattern: 'date',\n              token,\n              i,\n              j,\n              separator: '',\n              year: bestCandidate.year,\n              month: bestCandidate.month,\n              day: bestCandidate.day\n            });\n          }\n        }\n      }\n    }\n    return matches;\n  }\n  /*\n   * matches now contains all valid date strings in a way that is tricky to capture\n   * with regexes only. while thorough, it will contain some unintuitive noise:\n   *\n   * '2015_06_04', in addition to matching 2015_06_04, will also contain\n   * 5(!) other date matches: 15_06_04, 5_06_04, ..., even 2015 (matched as 5/1/2020)\n   *\n   * to reduce noise, remove date matches that are strict substrings of others\n   */\n  filterNoise(matches) {\n    return matches.filter(match => {\n      let isSubmatch = false;\n      const matchesLength = matches.length;\n      for (let o = 0; o < matchesLength; o += 1) {\n        const otherMatch = matches[o];\n        if (match !== otherMatch) {\n          if (otherMatch.i <= match.i && otherMatch.j >= match.j) {\n            isSubmatch = true;\n            break;\n          }\n        }\n      }\n      return !isSubmatch;\n    });\n  }\n  /*\n   * given a 3-tuple, discard if:\n   *   middle int is over 31 (for all dmy formats, years are never allowed in the middle)\n   *   middle int is zero\n   *   any int is over the max allowable year\n   *   any int is over two digits but under the min allowable year\n   *   2 integers are over 31, the max allowable day\n   *   2 integers are zero\n   *   all integers are over 12, the max allowable month\n   */\n  // eslint-disable-next-line complexity, max-statements\n  mapIntegersToDayMonthYear(integers) {\n    if (integers[1] > 31 || integers[1] <= 0) {\n      return null;\n    }\n    let over12 = 0;\n    let over31 = 0;\n    let under1 = 0;\n    for (let o = 0, len1 = integers.length; o < len1; o += 1) {\n      const int = integers[o];\n      if (int > 99 && int < DATE_MIN_YEAR || int > DATE_MAX_YEAR) {\n        return null;\n      }\n      if (int > 31) {\n        over31 += 1;\n      }\n      if (int > 12) {\n        over12 += 1;\n      }\n      if (int <= 0) {\n        under1 += 1;\n      }\n    }\n    if (over31 >= 2 || over12 === 3 || under1 >= 2) {\n      return null;\n    }\n    return this.getDayMonth(integers);\n  }\n  // eslint-disable-next-line max-statements\n  getDayMonth(integers) {\n    // first look for a four digit year: yyyy + daymonth or daymonth + yyyy\n    const possibleYearSplits = [[integers[2], integers.slice(0, 2)], [integers[0], integers.slice(1, 3)] // year first\n    ];\n\n    const possibleYearSplitsLength = possibleYearSplits.length;\n    for (let j = 0; j < possibleYearSplitsLength; j += 1) {\n      const [y, rest] = possibleYearSplits[j];\n      if (DATE_MIN_YEAR <= y && y <= DATE_MAX_YEAR) {\n        const dm = this.mapIntegersToDayMonth(rest);\n        if (dm != null) {\n          return {\n            year: y,\n            month: dm.month,\n            day: dm.day\n          };\n        }\n        /*\n         * for a candidate that includes a four-digit year,\n         * when the remaining integers don't match to a day and month,\n         * it is not a date.\n         */\n        return null;\n      }\n    }\n    // given no four-digit year, two digit years are the most flexible int to match, so\n    // try to parse a day-month out of integers[0..1] or integers[1..0]\n    for (let k = 0; k < possibleYearSplitsLength; k += 1) {\n      const [y, rest] = possibleYearSplits[k];\n      const dm = this.mapIntegersToDayMonth(rest);\n      if (dm != null) {\n        return {\n          year: this.twoToFourDigitYear(y),\n          month: dm.month,\n          day: dm.day\n        };\n      }\n    }\n    return null;\n  }\n  mapIntegersToDayMonth(integers) {\n    const temp = [integers, integers.slice().reverse()];\n    for (let i = 0; i < temp.length; i += 1) {\n      const data = temp[i];\n      const day = data[0];\n      const month = data[1];\n      if (day >= 1 && day <= 31 && month >= 1 && month <= 12) {\n        return {\n          day,\n          month\n        };\n      }\n    }\n    return null;\n  }\n  twoToFourDigitYear(year) {\n    if (year > 99) {\n      return year;\n    }\n    if (year > 50) {\n      // 87 -> 1987\n      return year + 1900;\n    }\n    // 15 -> 2015\n    return year + 2000;\n  }\n}\n\nexport { MatchDate as default };\n//# sourceMappingURL=matching.esm.js.map\n","const peq = new Uint32Array(0x10000);\nconst myers_32 = (a, b) => {\n    const n = a.length;\n    const m = b.length;\n    const lst = 1 << (n - 1);\n    let pv = -1;\n    let mv = 0;\n    let sc = n;\n    let i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] |= 1 << i;\n    }\n    for (i = 0; i < m; i++) {\n        let eq = peq[b.charCodeAt(i)];\n        const xv = eq | mv;\n        eq |= ((eq & pv) + pv) ^ pv;\n        mv |= ~(eq | pv);\n        pv &= eq;\n        if (mv & lst) {\n            sc++;\n        }\n        if (pv & lst) {\n            sc--;\n        }\n        mv = (mv << 1) | 1;\n        pv = (pv << 1) | ~(xv | mv);\n        mv &= xv;\n    }\n    i = n;\n    while (i--) {\n        peq[a.charCodeAt(i)] = 0;\n    }\n    return sc;\n};\nconst myers_x = (b, a) => {\n    const n = a.length;\n    const m = b.length;\n    const mhc = [];\n    const phc = [];\n    const hsize = Math.ceil(n / 32);\n    const vsize = Math.ceil(m / 32);\n    for (let i = 0; i < hsize; i++) {\n        phc[i] = -1;\n        mhc[i] = 0;\n    }\n    let j = 0;\n    for (; j < vsize - 1; j++) {\n        let mv = 0;\n        let pv = -1;\n        const start = j * 32;\n        const vlen = Math.min(32, m) + start;\n        for (let k = start; k < vlen; k++) {\n            peq[b.charCodeAt(k)] |= 1 << k;\n        }\n        for (let i = 0; i < n; i++) {\n            const eq = peq[a.charCodeAt(i)];\n            const pb = (phc[(i / 32) | 0] >>> i) & 1;\n            const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n            const xv = eq | mv;\n            const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n            let ph = mv | ~(xh | pv);\n            let mh = pv & xh;\n            if ((ph >>> 31) ^ pb) {\n                phc[(i / 32) | 0] ^= 1 << i;\n            }\n            if ((mh >>> 31) ^ mb) {\n                mhc[(i / 32) | 0] ^= 1 << i;\n            }\n            ph = (ph << 1) | pb;\n            mh = (mh << 1) | mb;\n            pv = mh | ~(xv | ph);\n            mv = ph & xv;\n        }\n        for (let k = start; k < vlen; k++) {\n            peq[b.charCodeAt(k)] = 0;\n        }\n    }\n    let mv = 0;\n    let pv = -1;\n    const start = j * 32;\n    const vlen = Math.min(32, m - start) + start;\n    for (let k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] |= 1 << k;\n    }\n    let score = m;\n    for (let i = 0; i < n; i++) {\n        const eq = peq[a.charCodeAt(i)];\n        const pb = (phc[(i / 32) | 0] >>> i) & 1;\n        const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n        const xv = eq | mv;\n        const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n        let ph = mv | ~(xh | pv);\n        let mh = pv & xh;\n        score += (ph >>> (m - 1)) & 1;\n        score -= (mh >>> (m - 1)) & 1;\n        if ((ph >>> 31) ^ pb) {\n            phc[(i / 32) | 0] ^= 1 << i;\n        }\n        if ((mh >>> 31) ^ mb) {\n            mhc[(i / 32) | 0] ^= 1 << i;\n        }\n        ph = (ph << 1) | pb;\n        mh = (mh << 1) | mb;\n        pv = mh | ~(xv | ph);\n        mv = ph & xv;\n    }\n    for (let k = start; k < vlen; k++) {\n        peq[b.charCodeAt(k)] = 0;\n    }\n    return score;\n};\nconst distance = (a, b) => {\n    if (a.length < b.length) {\n        const tmp = b;\n        b = a;\n        a = tmp;\n    }\n    if (b.length === 0) {\n        return a.length;\n    }\n    if (a.length <= 32) {\n        return myers_32(a, b);\n    }\n    return myers_x(a, b);\n};\nconst closest = (str, arr) => {\n    let min_distance = Infinity;\n    let min_index = 0;\n    for (let i = 0; i < arr.length; i++) {\n        const dist = distance(str, arr[i]);\n        if (dist < min_distance) {\n            min_distance = dist;\n            min_index = i;\n        }\n    }\n    return arr[min_index];\n};\nexport { closest, distance };\n","import { distance } from 'fastest-levenshtein';\n\nconst getUsedThreshold = (password, entry, threshold) => {\n  const isPasswordToShort = password.length <= entry.length;\n  const isThresholdLongerThanPassword = password.length <= threshold;\n  const shouldUsePasswordLength = isPasswordToShort || isThresholdLongerThanPassword;\n  // if password is too small use the password length divided by 4 while the threshold needs to be at least 1\n  return shouldUsePasswordLength ? Math.ceil(password.length / 4) : threshold;\n};\nconst findLevenshteinDistance = (password, rankedDictionary, threshold) => {\n  let foundDistance = 0;\n  const found = Object.keys(rankedDictionary).find(entry => {\n    const usedThreshold = getUsedThreshold(password, entry, threshold);\n    if (Math.abs(password.length - entry.length) > usedThreshold) {\n      return false;\n    }\n    const foundEntryDistance = distance(password, entry);\n    const isInThreshold = foundEntryDistance <= usedThreshold;\n    if (isInThreshold) {\n      foundDistance = foundEntryDistance;\n    }\n    return isInThreshold;\n  });\n  if (found) {\n    return {\n      levenshteinDistance: foundDistance,\n      levenshteinDistanceEntry: found\n    };\n  }\n  return {};\n};\n\nexport { findLevenshteinDistance as default };\n//# sourceMappingURL=levenshtein.esm.js.map\n","var l33tTable = {\n  a: ['4', '@'],\n  b: ['8'],\n  c: ['(', '{', '[', '<'],\n  d: ['6', '|)'],\n  e: ['3'],\n  f: ['#'],\n  g: ['6', '9', '&'],\n  h: ['#', '|-|'],\n  i: ['1', '!', '|'],\n  k: ['<', '|<'],\n  l: ['!', '1', '|', '7'],\n  m: ['^^', 'nn', '2n', '/\\\\\\\\/\\\\\\\\'],\n  n: ['//'],\n  o: ['0', '()'],\n  q: ['9'],\n  u: ['|_|'],\n  s: ['$', '5'],\n  t: ['+', '7'],\n  v: ['<', '>', '/'],\n  w: ['^/', 'uu', 'vv', '2u', '2v', '\\\\\\\\/\\\\\\\\/'],\n  x: ['%', '><'],\n  z: ['2']\n};\n\nexport { l33tTable as default };\n//# sourceMappingURL=l33tTable.esm.js.map\n","var translationKeys = {\n  warnings: {\n    straightRow: 'straightRow',\n    keyPattern: 'keyPattern',\n    simpleRepeat: 'simpleRepeat',\n    extendedRepeat: 'extendedRepeat',\n    sequences: 'sequences',\n    recentYears: 'recentYears',\n    dates: 'dates',\n    topTen: 'topTen',\n    topHundred: 'topHundred',\n    common: 'common',\n    similarToCommon: 'similarToCommon',\n    wordByItself: 'wordByItself',\n    namesByThemselves: 'namesByThemselves',\n    commonNames: 'commonNames',\n    userInputs: 'userInputs',\n    pwned: 'pwned'\n  },\n  suggestions: {\n    l33t: 'l33t',\n    reverseWords: 'reverseWords',\n    allUppercase: 'allUppercase',\n    capitalization: 'capitalization',\n    dates: 'dates',\n    recentYears: 'recentYears',\n    associatedYears: 'associatedYears',\n    sequences: 'sequences',\n    repeated: 'repeated',\n    longerKeyboardPattern: 'longerKeyboardPattern',\n    anotherWord: 'anotherWord',\n    useWords: 'useWords',\n    noNeed: 'noNeed',\n    pwned: 'pwned'\n  },\n  timeEstimation: {\n    ltSecond: 'ltSecond',\n    second: 'second',\n    seconds: 'seconds',\n    minute: 'minute',\n    minutes: 'minutes',\n    hour: 'hour',\n    hours: 'hours',\n    day: 'day',\n    days: 'days',\n    month: 'month',\n    months: 'months',\n    year: 'year',\n    years: 'years',\n    centuries: 'centuries'\n  }\n};\n\nexport { translationKeys as default };\n//# sourceMappingURL=translationKeys.esm.js.map\n","class TrieNode {\n  constructor(parents = []) {\n    this.parents = parents;\n    // eslint-disable-next-line no-use-before-define\n    this.children = new Map();\n  }\n  addSub(key, ...subs) {\n    const firstChar = key.charAt(0);\n    if (!this.children.has(firstChar)) {\n      this.children.set(firstChar, new TrieNode([...this.parents, firstChar]));\n    }\n    let cur = this.children.get(firstChar);\n    for (let i = 1; i < key.length; i += 1) {\n      const c = key.charAt(i);\n      if (!cur.hasChild(c)) {\n        cur.addChild(c);\n      }\n      cur = cur.getChild(c);\n    }\n    cur.subs = (cur.subs || []).concat(subs);\n    return this;\n  }\n  getChild(child) {\n    return this.children.get(child);\n  }\n  isTerminal() {\n    return !!this.subs;\n  }\n  addChild(child) {\n    if (!this.hasChild(child)) {\n      this.children.set(child, new TrieNode([...this.parents, child]));\n    }\n  }\n  hasChild(child) {\n    return this.children.has(child);\n  }\n}\n\nexport { TrieNode as default };\n//# sourceMappingURL=TrieNode.esm.js.map\n","var l33tTableToTrieNode = ((l33tTable, triNode) => {\n  Object.entries(l33tTable).forEach(([letter, substitutions]) => {\n    substitutions.forEach(substitution => {\n      triNode.addSub(substitution, letter);\n    });\n  });\n  return triNode;\n});\n\nexport { l33tTableToTrieNode as default };\n//# sourceMappingURL=l33tTableToTrieNode.esm.js.map\n","import { buildRankedDictionary } from './helper.esm.js';\nimport l33tTable from './data/l33tTable.esm.js';\nimport translationKeys from './data/translationKeys.esm.js';\nimport TrieNode from './matcher/dictionary/variants/matching/unmunger/TrieNode.esm.js';\nimport l33tTableToTrieNode from './matcher/dictionary/variants/matching/unmunger/l33tTableToTrieNode.esm.js';\n\nclass Options {\n  constructor() {\n    this.matchers = {};\n    this.l33tTable = l33tTable;\n    this.trieNodeRoot = l33tTableToTrieNode(l33tTable, new TrieNode());\n    this.dictionary = {\n      userInputs: []\n    };\n    this.rankedDictionaries = {};\n    this.rankedDictionariesMaxWordSize = {};\n    this.translations = translationKeys;\n    this.graphs = {};\n    this.useLevenshteinDistance = false;\n    this.levenshteinThreshold = 2;\n    this.l33tMaxSubstitutions = 100;\n    this.maxLength = 256;\n    this.setRankedDictionaries();\n  }\n  // eslint-disable-next-line max-statements,complexity\n  setOptions(options = {}) {\n    if (options.l33tTable) {\n      this.l33tTable = options.l33tTable;\n      this.trieNodeRoot = l33tTableToTrieNode(options.l33tTable, new TrieNode());\n    }\n    if (options.dictionary) {\n      this.dictionary = options.dictionary;\n      this.setRankedDictionaries();\n    }\n    if (options.translations) {\n      this.setTranslations(options.translations);\n    }\n    if (options.graphs) {\n      this.graphs = options.graphs;\n    }\n    if (options.useLevenshteinDistance !== undefined) {\n      this.useLevenshteinDistance = options.useLevenshteinDistance;\n    }\n    if (options.levenshteinThreshold !== undefined) {\n      this.levenshteinThreshold = options.levenshteinThreshold;\n    }\n    if (options.l33tMaxSubstitutions !== undefined) {\n      this.l33tMaxSubstitutions = options.l33tMaxSubstitutions;\n    }\n    if (options.maxLength !== undefined) {\n      this.maxLength = options.maxLength;\n    }\n  }\n  setTranslations(translations) {\n    if (this.checkCustomTranslations(translations)) {\n      this.translations = translations;\n    } else {\n      throw new Error('Invalid translations object fallback to keys');\n    }\n  }\n  checkCustomTranslations(translations) {\n    let valid = true;\n    Object.keys(translationKeys).forEach(type => {\n      if (type in translations) {\n        const translationType = type;\n        Object.keys(translationKeys[translationType]).forEach(key => {\n          if (!(key in translations[translationType])) {\n            valid = false;\n          }\n        });\n      } else {\n        valid = false;\n      }\n    });\n    return valid;\n  }\n  setRankedDictionaries() {\n    const rankedDictionaries = {};\n    const rankedDictionariesMaxWorkSize = {};\n    Object.keys(this.dictionary).forEach(name => {\n      rankedDictionaries[name] = buildRankedDictionary(this.dictionary[name]);\n      rankedDictionariesMaxWorkSize[name] = this.getRankedDictionariesMaxWordSize(this.dictionary[name]);\n    });\n    this.rankedDictionaries = rankedDictionaries;\n    this.rankedDictionariesMaxWordSize = rankedDictionariesMaxWorkSize;\n  }\n  getRankedDictionariesMaxWordSize(list) {\n    const data = list.map(el => {\n      if (typeof el !== 'string') {\n        return el.toString().length;\n      }\n      return el.length;\n    });\n    // do not use Math.max(...data) because it can result in max stack size error because every entry will be used as an argument\n    if (data.length === 0) {\n      return 0;\n    }\n    return data.reduce((a, b) => Math.max(a, b), -Infinity);\n  }\n  buildSanitizedRankedDictionary(list) {\n    const sanitizedInputs = [];\n    list.forEach(input => {\n      const inputType = typeof input;\n      if (inputType === 'string' || inputType === 'number' || inputType === 'boolean') {\n        sanitizedInputs.push(input.toString().toLowerCase());\n      }\n    });\n    return buildRankedDictionary(sanitizedInputs);\n  }\n  extendUserInputsDictionary(dictionary) {\n    if (!this.dictionary.userInputs) {\n      this.dictionary.userInputs = [];\n    }\n    const newList = [...this.dictionary.userInputs, ...dictionary];\n    this.rankedDictionaries.userInputs = this.buildSanitizedRankedDictionary(newList);\n    this.rankedDictionariesMaxWordSize.userInputs = this.getRankedDictionariesMaxWordSize(newList);\n  }\n  addMatcher(name, matcher) {\n    if (this.matchers[name]) {\n      console.info(`Matcher ${name} already exists`);\n    } else {\n      this.matchers[name] = matcher;\n    }\n  }\n}\nconst zxcvbnOptions = new Options();\n\nexport { Options, zxcvbnOptions };\n//# sourceMappingURL=Options.esm.js.map\n","/*\n * -------------------------------------------------------------------------------\n *  Dictionary reverse matching --------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchReverse {\n  constructor(defaultMatch) {\n    this.defaultMatch = defaultMatch;\n  }\n  match({\n    password\n  }) {\n    const passwordReversed = password.split('').reverse().join('');\n    return this.defaultMatch({\n      password: passwordReversed\n    }).map(match => ({\n      ...match,\n      token: match.token.split('').reverse().join(''),\n      reversed: true,\n      // map coordinates back to original string\n      i: password.length - 1 - match.j,\n      j: password.length - 1 - match.i\n    }));\n  }\n}\n\nexport { MatchReverse as default };\n//# sourceMappingURL=reverse.esm.js.map\n","class CleanPasswords {\n  constructor({\n    substr,\n    limit,\n    trieRoot\n  }) {\n    this.buffer = [];\n    this.finalPasswords = [];\n    this.substr = substr;\n    this.limit = limit;\n    this.trieRoot = trieRoot;\n  }\n  getAllPossibleSubsAtIndex(index) {\n    const nodes = [];\n    let cur = this.trieRoot;\n    for (let i = index; i < this.substr.length; i += 1) {\n      const character = this.substr.charAt(i);\n      cur = cur.getChild(character);\n      if (!cur) {\n        break;\n      }\n      nodes.push(cur);\n    }\n    return nodes;\n  }\n  // eslint-disable-next-line complexity,max-statements\n  helper({\n    onlyFullSub,\n    isFullSub,\n    index,\n    subIndex,\n    changes,\n    lastSubLetter,\n    consecutiveSubCount\n  }) {\n    if (this.finalPasswords.length >= this.limit) {\n      return;\n    }\n    if (index === this.substr.length) {\n      if (onlyFullSub === isFullSub) {\n        this.finalPasswords.push({\n          password: this.buffer.join(''),\n          changes\n        });\n      }\n      return;\n    }\n    // first, exhaust all possible substitutions at this index\n    const nodes = [...this.getAllPossibleSubsAtIndex(index)];\n    let hasSubs = false;\n    // iterate backward to get wider substitutions first\n    for (let i = index + nodes.length - 1; i >= index; i -= 1) {\n      const cur = nodes[i - index];\n      if (cur.isTerminal()) {\n        // Skip if this would be a 4th or more consecutive substitution of the same letter\n        // this should work in all language as there shouldn't be the same letter more than four times in a row\n        // So we can ignore the rest to save calculation time\n        if (lastSubLetter === cur.parents.join('') && consecutiveSubCount >= 3) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n        hasSubs = true;\n        const subs = cur.subs;\n        // eslint-disable-next-line no-restricted-syntax\n        for (const sub of subs) {\n          this.buffer.push(sub);\n          const newSubs = changes.concat({\n            i: subIndex,\n            letter: sub,\n            substitution: cur.parents.join('')\n          });\n          // recursively build the rest of the string\n          this.helper({\n            onlyFullSub,\n            isFullSub,\n            index: i + 1,\n            subIndex: subIndex + sub.length,\n            changes: newSubs,\n            lastSubLetter: cur.parents.join(''),\n            consecutiveSubCount: lastSubLetter === cur.parents.join('') ? consecutiveSubCount + 1 : 1\n          });\n          // backtrack by ignoring the added postfix\n          this.buffer.pop();\n          if (this.finalPasswords.length >= this.limit) {\n            return;\n          }\n        }\n      }\n    }\n    // next, generate all combos without doing a substitution at this index\n    // if a partial substitution is requested or there are no substitutions at this index\n    if (!onlyFullSub || !hasSubs) {\n      const firstChar = this.substr.charAt(index);\n      this.buffer.push(firstChar);\n      this.helper({\n        onlyFullSub,\n        isFullSub: isFullSub && !hasSubs,\n        index: index + 1,\n        subIndex: subIndex + 1,\n        changes,\n        lastSubLetter,\n        consecutiveSubCount\n      });\n      this.buffer.pop();\n    }\n  }\n  getAll() {\n    // only full substitution\n    this.helper({\n      onlyFullSub: true,\n      isFullSub: true,\n      index: 0,\n      subIndex: 0,\n      changes: [],\n      lastSubLetter: undefined,\n      consecutiveSubCount: 0\n    });\n    // only partial substitution\n    this.helper({\n      onlyFullSub: false,\n      isFullSub: true,\n      index: 0,\n      subIndex: 0,\n      changes: [],\n      lastSubLetter: undefined,\n      consecutiveSubCount: 0\n    });\n    return this.finalPasswords;\n  }\n}\nconst getCleanPasswords = (password, limit, trieRoot) => {\n  const helper = new CleanPasswords({\n    substr: password,\n    limit,\n    trieRoot\n  });\n  return helper.getAll();\n};\n\nexport { getCleanPasswords as default };\n//# sourceMappingURL=getCleanPasswords.esm.js.map\n","import { zxcvbnOptions } from '../../../../Options.esm.js';\nimport getCleanPasswords from './unmunger/getCleanPasswords.esm.js';\n\nconst getExtras = (passwordWithSubs, i, j) => {\n  const previousChanges = passwordWithSubs.changes.filter(changes => {\n    return changes.i < i;\n  });\n  const iUnsubbed = previousChanges.reduce((value, change) => {\n    return value - change.letter.length + change.substitution.length;\n  }, i);\n  const usedChanges = passwordWithSubs.changes.filter(changes => {\n    return changes.i >= i && changes.i <= j;\n  });\n  const jUnsubbed = usedChanges.reduce((value, change) => {\n    return value - change.letter.length + change.substitution.length;\n  }, j - i + iUnsubbed);\n  const filtered = [];\n  const subDisplay = [];\n  usedChanges.forEach(value => {\n    const existingIndex = filtered.findIndex(t => {\n      return t.letter === value.letter && t.substitution === value.substitution;\n    });\n    if (existingIndex < 0) {\n      filtered.push({\n        letter: value.letter,\n        substitution: value.substitution\n      });\n      subDisplay.push(`${value.substitution} -> ${value.letter}`);\n    }\n  });\n  return {\n    i: iUnsubbed,\n    j: jUnsubbed,\n    subs: filtered,\n    subDisplay: subDisplay.join(', ')\n  };\n};\n/*\n * -------------------------------------------------------------------------------\n *  Dictionary l33t matching -----------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchL33t {\n  constructor(defaultMatch) {\n    this.defaultMatch = defaultMatch;\n  }\n  isAlreadyIncluded(matches, newMatch) {\n    return matches.some(l33tMatch => {\n      return Object.entries(l33tMatch).every(([key, value]) => {\n        return key === 'subs' || value === newMatch[key];\n      });\n    });\n  }\n  match({\n    password\n  }) {\n    const matches = [];\n    const subbedPasswords = getCleanPasswords(password, zxcvbnOptions.l33tMaxSubstitutions, zxcvbnOptions.trieNodeRoot);\n    let hasFullMatch = false;\n    let isFullSubstitution = true;\n    subbedPasswords.forEach(subbedPassword => {\n      if (hasFullMatch) {\n        return;\n      }\n      const matchedDictionary = this.defaultMatch({\n        password: subbedPassword.password,\n        useLevenshtein: isFullSubstitution\n      });\n      // only the first entry has a full substitution\n      isFullSubstitution = false;\n      matchedDictionary.forEach(match => {\n        if (!hasFullMatch) {\n          hasFullMatch = match.i === 0 && match.j === password.length - 1;\n        }\n        const extras = getExtras(subbedPassword, match.i, match.j);\n        const token = password.slice(extras.i, +extras.j + 1 || 9e9);\n        const newMatch = {\n          ...match,\n          l33t: true,\n          token,\n          ...extras\n        };\n        const alreadyIncluded = this.isAlreadyIncluded(matches, newMatch);\n        // only return the matches that contain an actual substitution\n        if (token.toLowerCase() !== match.matchedWord && !alreadyIncluded) {\n          matches.push(newMatch);\n        }\n      });\n    });\n    // filter single-character l33t matches to reduce noise.\n    // otherwise '1' matches 'i', '4' matches 'a', both very common English words\n    // with low dictionary rank.\n    return matches.filter(match => match.token.length > 1);\n  }\n}\n\nexport { MatchL33t as default };\n//# sourceMappingURL=l33t.esm.js.map\n","import findLevenshteinDistance from '../../levenshtein.esm.js';\nimport { sorted } from '../../helper.esm.js';\nimport { zxcvbnOptions } from '../../Options.esm.js';\nimport MatchReverse from './variants/matching/reverse.esm.js';\nimport MatchL33t from './variants/matching/l33t.esm.js';\n\nclass MatchDictionary {\n  constructor() {\n    this.l33t = new MatchL33t(this.defaultMatch);\n    this.reverse = new MatchReverse(this.defaultMatch);\n  }\n  match({\n    password\n  }) {\n    const matches = [...this.defaultMatch({\n      password\n    }), ...this.reverse.match({\n      password\n    }), ...this.l33t.match({\n      password\n    })];\n    return sorted(matches);\n  }\n  defaultMatch({\n    password,\n    useLevenshtein = true\n  }) {\n    const matches = [];\n    const passwordLength = password.length;\n    const passwordLower = password.toLowerCase();\n    // eslint-disable-next-line complexity,max-statements\n    Object.keys(zxcvbnOptions.rankedDictionaries).forEach(dictionaryName => {\n      const rankedDict = zxcvbnOptions.rankedDictionaries[dictionaryName];\n      const longestDictionaryWordSize = zxcvbnOptions.rankedDictionariesMaxWordSize[dictionaryName];\n      const searchWidth = Math.min(longestDictionaryWordSize, passwordLength);\n      for (let i = 0; i < passwordLength; i += 1) {\n        const searchEnd = Math.min(i + searchWidth, passwordLength);\n        for (let j = i; j < searchEnd; j += 1) {\n          const usedPassword = passwordLower.slice(i, +j + 1 || 9e9);\n          const isInDictionary = (usedPassword in rankedDict);\n          let foundLevenshteinDistance = {};\n          // only use levenshtein distance on full password to minimize the performance drop\n          // and because otherwise there would be to many false positives\n          const isFullPassword = i === 0 && j === passwordLength - 1;\n          if (zxcvbnOptions.useLevenshteinDistance && isFullPassword && !isInDictionary && useLevenshtein) {\n            foundLevenshteinDistance = findLevenshteinDistance(usedPassword, rankedDict, zxcvbnOptions.levenshteinThreshold);\n          }\n          const isLevenshteinMatch = Object.keys(foundLevenshteinDistance).length !== 0;\n          if (isInDictionary || isLevenshteinMatch) {\n            const usedRankPassword = isLevenshteinMatch ? foundLevenshteinDistance.levenshteinDistanceEntry : usedPassword;\n            const rank = rankedDict[usedRankPassword];\n            matches.push({\n              pattern: 'dictionary',\n              i,\n              j,\n              token: password.slice(i, +j + 1 || 9e9),\n              matchedWord: usedPassword,\n              rank,\n              dictionaryName: dictionaryName,\n              reversed: false,\n              l33t: false,\n              ...foundLevenshteinDistance\n            });\n          }\n        }\n      }\n    });\n    return matches;\n  }\n}\n\nexport { MatchDictionary as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { REGEXEN } from '../../data/const.esm.js';\nimport { sorted } from '../../helper.esm.js';\n\n/*\n * -------------------------------------------------------------------------------\n *  regex matching ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass MatchRegex {\n  match({\n    password,\n    regexes = REGEXEN\n  }) {\n    const matches = [];\n    Object.keys(regexes).forEach(name => {\n      const regex = regexes[name];\n      regex.lastIndex = 0; // keeps regexMatch stateless\n      let regexMatch;\n      // eslint-disable-next-line no-cond-assign\n      while (regexMatch = regex.exec(password)) {\n        if (regexMatch) {\n          const token = regexMatch[0];\n          matches.push({\n            pattern: 'regex',\n            token,\n            i: regexMatch.index,\n            j: regexMatch.index + regexMatch[0].length - 1,\n            regexName: name,\n            regexMatch\n          });\n        }\n      }\n    });\n    return sorted(matches);\n  }\n}\n\nexport { MatchRegex as default };\n//# sourceMappingURL=matching.esm.js.map\n","var utils = {\n  // binomial coefficients\n  // src: http://blog.plover.com/math/choose.html\n  nCk(n, k) {\n    let count = n;\n    if (k > count) {\n      return 0;\n    }\n    if (k === 0) {\n      return 1;\n    }\n    let coEff = 1;\n    for (let i = 1; i <= k; i += 1) {\n      coEff *= count;\n      coEff /= i;\n      count -= 1;\n    }\n    return coEff;\n  },\n  log10(n) {\n    if (n === 0) return 0;\n    return Math.log(n) / Math.log(10); // IE doesn't support Math.log10 :(\n  },\n\n  log2(n) {\n    return Math.log(n) / Math.log(2);\n  },\n  factorial(num) {\n    let rval = 1;\n    for (let i = 2; i <= num; i += 1) rval *= i;\n    return rval;\n  }\n};\n\nexport { utils as default };\n//# sourceMappingURL=utils.esm.js.map\n","import { BRUTEFORCE_CARDINALITY, MIN_SUBMATCH_GUESSES_SINGLE_CHAR, MIN_SUBMATCH_GUESSES_MULTI_CHAR } from '../../data/const.esm.js';\n\nvar bruteforceMatcher = (({\n  token\n}) => {\n  let guesses = BRUTEFORCE_CARDINALITY ** token.length;\n  if (guesses === Number.POSITIVE_INFINITY) {\n    guesses = Number.MAX_VALUE;\n  }\n  let minGuesses;\n  // small detail: make bruteforce matches at minimum one guess bigger than smallest allowed\n  // submatch guesses, such that non-bruteforce submatches over the same [i..j] take precedence.\n  if (token.length === 1) {\n    minGuesses = MIN_SUBMATCH_GUESSES_SINGLE_CHAR + 1;\n  } else {\n    minGuesses = MIN_SUBMATCH_GUESSES_MULTI_CHAR + 1;\n  }\n  return Math.max(guesses, minGuesses);\n});\n\nexport { bruteforceMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import { REFERENCE_YEAR, MIN_YEAR_SPACE } from '../../data/const.esm.js';\n\nvar dateMatcher = (({\n  year,\n  separator\n}) => {\n  // base guesses: (year distance from REFERENCE_YEAR) * num_days * num_years\n  const yearSpace = Math.max(Math.abs(year - REFERENCE_YEAR), MIN_YEAR_SPACE);\n  let guesses = yearSpace * 365;\n  // add factor of 4 for separator selection (one of ~4 choices)\n  if (separator) {\n    guesses *= 4;\n  }\n  return guesses;\n});\n\nexport { dateMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import utils from '../../../../scoring/utils.esm.js';\nimport { ALPHA_INVERTED, ALL_LOWER_INVERTED, ONE_UPPER, ONE_LOWER, START_UPPER, END_UPPER, ALL_UPPER_INVERTED } from '../../../../data/const.esm.js';\n\nconst getVariations = cleanedWord => {\n  const wordArray = cleanedWord.split('');\n  const upperCaseCount = wordArray.filter(char => char.match(ONE_UPPER)).length;\n  const lowerCaseCount = wordArray.filter(char => char.match(ONE_LOWER)).length;\n  let variations = 0;\n  const variationLength = Math.min(upperCaseCount, lowerCaseCount);\n  for (let i = 1; i <= variationLength; i += 1) {\n    variations += utils.nCk(upperCaseCount + lowerCaseCount, i);\n  }\n  return variations;\n};\nvar uppercaseVariant = (word => {\n  // clean words of non alpha characters to remove the reward effekt to capitalize the first letter https://github.com/dropbox/zxcvbn/issues/232\n  const cleanedWord = word.replace(ALPHA_INVERTED, '');\n  if (cleanedWord.match(ALL_LOWER_INVERTED) || cleanedWord.toLowerCase() === cleanedWord) {\n    return 1;\n  }\n  // a capitalized word is the most common capitalization scheme,\n  // so it only doubles the search space (uncapitalized + capitalized).\n  // all caps and end-capitalized are common enough too, underestimate as 2x factor to be safe.\n  const commonCases = [START_UPPER, END_UPPER, ALL_UPPER_INVERTED];\n  const commonCasesLength = commonCases.length;\n  for (let i = 0; i < commonCasesLength; i += 1) {\n    const regex = commonCases[i];\n    if (cleanedWord.match(regex)) {\n      return 2;\n    }\n  }\n  // otherwise calculate the number of ways to capitalize U+L uppercase+lowercase letters\n  // with U uppercase letters or less. or, if there's more uppercase than lower (for eg. PASSwORD),\n  // the number of ways to lowercase U+L letters with L lowercase letters or less.\n  return getVariations(cleanedWord);\n});\n\nexport { uppercaseVariant as default };\n//# sourceMappingURL=uppercase.esm.js.map\n","import utils from '../../../../scoring/utils.esm.js';\n\nconst countSubstring = (string, substring) => {\n  let count = 0;\n  let pos = string.indexOf(substring);\n  while (pos >= 0) {\n    count += 1;\n    pos = string.indexOf(substring, pos + substring.length);\n  }\n  return count;\n};\nconst getCounts = ({\n  sub,\n  token\n}) => {\n  // lower-case match.token before calculating: capitalization shouldn't affect l33t calc.\n  const tokenLower = token.toLowerCase();\n  // num of subbed chars\n  const subbedCount = countSubstring(tokenLower, sub.substitution);\n  // num of unsubbed chars\n  const unsubbedCount = countSubstring(tokenLower, sub.letter);\n  return {\n    subbedCount,\n    unsubbedCount\n  };\n};\nvar l33tVariant = (({\n  l33t,\n  subs,\n  token\n}) => {\n  if (!l33t) {\n    return 1;\n  }\n  let variations = 1;\n  subs.forEach(sub => {\n    const {\n      subbedCount,\n      unsubbedCount\n    } = getCounts({\n      sub,\n      token\n    });\n    if (subbedCount === 0 || unsubbedCount === 0) {\n      // for this sub, password is either fully subbed (444) or fully unsubbed (aaa)\n      // treat that as doubling the space (attacker needs to try fully subbed chars in addition to\n      // unsubbed.)\n      variations *= 2;\n    } else {\n      // this case is similar to capitalization:\n      // with aa44a, U = 3, S = 2, attacker needs to try unsubbed + one sub + two subs\n      const p = Math.min(unsubbedCount, subbedCount);\n      let possibilities = 0;\n      for (let i = 1; i <= p; i += 1) {\n        possibilities += utils.nCk(unsubbedCount + subbedCount, i);\n      }\n      variations *= possibilities;\n    }\n  });\n  return variations;\n});\n\nexport { l33tVariant as default };\n//# sourceMappingURL=l33t.esm.js.map\n","import uppercaseVariant from './variants/scoring/uppercase.esm.js';\nimport l33tVariant from './variants/scoring/l33t.esm.js';\n\nvar dictionaryMatcher = (({\n  rank,\n  reversed,\n  l33t,\n  subs,\n  token,\n  dictionaryName\n}) => {\n  const baseGuesses = rank; // keep these as properties for display purposes\n  const uppercaseVariations = uppercaseVariant(token);\n  const l33tVariations = l33tVariant({\n    l33t,\n    subs,\n    token\n  });\n  const reversedVariations = reversed && 2 || 1;\n  let calculation;\n  if (dictionaryName === 'diceware') {\n    // diceware dictionaries are special, so we get a simple scoring of 1/2 of 6^5 (6 digits on 5 dice)\n    // to get fix entropy of ~12.9 bits for every entry https://en.wikipedia.org/wiki/Diceware#:~:text=The%20level%20of,bits\n    calculation = 6 ** 5 / 2;\n  } else {\n    calculation = baseGuesses * uppercaseVariations * l33tVariations * reversedVariations;\n  }\n  return {\n    baseGuesses,\n    uppercaseVariations,\n    l33tVariations,\n    calculation\n  };\n});\n\nexport { dictionaryMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import { REFERENCE_YEAR, MIN_YEAR_SPACE } from '../../data/const.esm.js';\n\nvar regexMatcher = (({\n  regexName,\n  regexMatch,\n  token\n}) => {\n  const charClassBases = {\n    alphaLower: 26,\n    alphaUpper: 26,\n    alpha: 52,\n    alphanumeric: 62,\n    digits: 10,\n    symbols: 33\n  };\n  if (regexName in charClassBases) {\n    return charClassBases[regexName] ** token.length;\n  }\n  // TODO add more regex types for example special dates like 09.11\n  // eslint-disable-next-line default-case\n  switch (regexName) {\n    case 'recentYear':\n      // conservative estimate of year space: num years from REFERENCE_YEAR.\n      // if year is close to REFERENCE_YEAR, estimate a year space of MIN_YEAR_SPACE.\n      return Math.max(Math.abs(parseInt(regexMatch[0], 10) - REFERENCE_YEAR), MIN_YEAR_SPACE);\n  }\n  return 0;\n});\n\nexport { regexMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","var repeatMatcher = (({\n  baseGuesses,\n  repeatCount\n}) => baseGuesses * repeatCount);\n\nexport { repeatMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","var sequenceMatcher = (({\n  token,\n  ascending\n}) => {\n  const firstChr = token.charAt(0);\n  let baseGuesses = 0;\n  const startingPoints = ['a', 'A', 'z', 'Z', '0', '1', '9'];\n  // lower guesses for obvious starting points\n  if (startingPoints.includes(firstChr)) {\n    baseGuesses = 4;\n  } else if (firstChr.match(/\\d/)) {\n    baseGuesses = 10; // digits\n  } else {\n    // could give a higher base for uppercase,\n    // assigning 26 to both upper and lower sequences is more conservative.\n    baseGuesses = 26;\n  }\n  // need to try a descending sequence in addition to every ascending sequence ->\n  // 2x guesses\n  if (!ascending) {\n    baseGuesses *= 2;\n  }\n  return baseGuesses * token.length;\n});\n\nexport { sequenceMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import utils from '../../scoring/utils.esm.js';\nimport { zxcvbnOptions } from '../../Options.esm.js';\n\nconst calcAverageDegree = graph => {\n  let average = 0;\n  Object.keys(graph).forEach(key => {\n    const neighbors = graph[key];\n    average += neighbors.filter(entry => !!entry).length;\n  });\n  average /= Object.entries(graph).length;\n  return average;\n};\nconst estimatePossiblePatterns = ({\n  token,\n  graph,\n  turns\n}) => {\n  const startingPosition = Object.keys(zxcvbnOptions.graphs[graph]).length;\n  const averageDegree = calcAverageDegree(zxcvbnOptions.graphs[graph]);\n  let guesses = 0;\n  const tokenLength = token.length;\n  // # estimate the number of possible patterns w/ tokenLength or less with turns or less.\n  for (let i = 2; i <= tokenLength; i += 1) {\n    const possibleTurns = Math.min(turns, i - 1);\n    for (let j = 1; j <= possibleTurns; j += 1) {\n      guesses += utils.nCk(i - 1, j - 1) * startingPosition * averageDegree ** j;\n    }\n  }\n  return guesses;\n};\nvar spatialMatcher = (({\n  graph,\n  token,\n  shiftedCount,\n  turns\n}) => {\n  let guesses = estimatePossiblePatterns({\n    token,\n    graph,\n    turns\n  });\n  // add extra guesses for shifted keys. (% instead of 5, A instead of a.)\n  // math is similar to extra guesses of l33t substitutions in dictionary matches.\n  if (shiftedCount) {\n    const unShiftedCount = token.length - shiftedCount;\n    if (shiftedCount === 0 || unShiftedCount === 0) {\n      guesses *= 2;\n    } else {\n      let shiftedVariations = 0;\n      for (let i = 1; i <= Math.min(shiftedCount, unShiftedCount); i += 1) {\n        shiftedVariations += utils.nCk(shiftedCount + unShiftedCount, i);\n      }\n      guesses *= shiftedVariations;\n    }\n  }\n  return Math.round(guesses);\n});\n\nexport { spatialMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import { SEPERATOR_CHAR_COUNT } from '../../data/const.esm.js';\n\nvar separatorMatcher = (() => {\n  return SEPERATOR_CHAR_COUNT;\n});\n\nexport { separatorMatcher as default };\n//# sourceMappingURL=scoring.esm.js.map\n","import { MIN_SUBMATCH_GUESSES_SINGLE_CHAR, MIN_SUBMATCH_GUESSES_MULTI_CHAR } from '../data/const.esm.js';\nimport utils from './utils.esm.js';\nimport { zxcvbnOptions } from '../Options.esm.js';\nimport bruteforceMatcher from '../matcher/bruteforce/scoring.esm.js';\nimport dateMatcher from '../matcher/date/scoring.esm.js';\nimport dictionaryMatcher from '../matcher/dictionary/scoring.esm.js';\nimport regexMatcher from '../matcher/regex/scoring.esm.js';\nimport repeatMatcher from '../matcher/repeat/scoring.esm.js';\nimport sequenceMatcher from '../matcher/sequence/scoring.esm.js';\nimport spatialMatcher from '../matcher/spatial/scoring.esm.js';\nimport separatorMatcher from '../matcher/separator/scoring.esm.js';\n\nconst getMinGuesses = (match, password) => {\n  let minGuesses = 1;\n  if (match.token.length < password.length) {\n    if (match.token.length === 1) {\n      minGuesses = MIN_SUBMATCH_GUESSES_SINGLE_CHAR;\n    } else {\n      minGuesses = MIN_SUBMATCH_GUESSES_MULTI_CHAR;\n    }\n  }\n  return minGuesses;\n};\nconst matchers = {\n  bruteforce: bruteforceMatcher,\n  date: dateMatcher,\n  dictionary: dictionaryMatcher,\n  regex: regexMatcher,\n  repeat: repeatMatcher,\n  sequence: sequenceMatcher,\n  spatial: spatialMatcher,\n  separator: separatorMatcher\n};\nconst getScoring = (name, match) => {\n  if (matchers[name]) {\n    return matchers[name](match);\n  }\n  if (zxcvbnOptions.matchers[name] && 'scoring' in zxcvbnOptions.matchers[name]) {\n    return zxcvbnOptions.matchers[name].scoring(match);\n  }\n  return 0;\n};\n// ------------------------------------------------------------------------------\n// guess estimation -- one function per match pattern ---------------------------\n// ------------------------------------------------------------------------------\n// eslint-disable-next-line complexity, max-statements\nvar estimateGuesses = ((match, password) => {\n  const extraData = {};\n  // a match's guess estimate doesn't change. cache it.\n  if ('guesses' in match && match.guesses != null) {\n    return match;\n  }\n  const minGuesses = getMinGuesses(match, password);\n  const estimationResult = getScoring(match.pattern, match);\n  let guesses = 0;\n  if (typeof estimationResult === 'number') {\n    guesses = estimationResult;\n  } else if (match.pattern === 'dictionary') {\n    guesses = estimationResult.calculation;\n    extraData.baseGuesses = estimationResult.baseGuesses;\n    extraData.uppercaseVariations = estimationResult.uppercaseVariations;\n    extraData.l33tVariations = estimationResult.l33tVariations;\n  }\n  const matchGuesses = Math.max(guesses, minGuesses);\n  return {\n    ...match,\n    ...extraData,\n    guesses: matchGuesses,\n    guessesLog10: utils.log10(matchGuesses)\n  };\n});\n\nexport { estimateGuesses as default };\n//# sourceMappingURL=estimate.esm.js.map\n","import utils from './utils.esm.js';\nimport estimateGuesses from './estimate.esm.js';\nimport { MIN_GUESSES_BEFORE_GROWING_SEQUENCE } from '../data/const.esm.js';\n\nconst scoringHelper = {\n  password: '',\n  optimal: {},\n  excludeAdditive: false,\n  separatorRegex: undefined,\n  fillArray(size, valueType) {\n    const result = [];\n    for (let i = 0; i < size; i += 1) {\n      let value = [];\n      if (valueType === 'object') {\n        value = {};\n      }\n      result.push(value);\n    }\n    return result;\n  },\n  // helper: make bruteforce match objects spanning i to j, inclusive.\n  makeBruteforceMatch(i, j) {\n    return {\n      pattern: 'bruteforce',\n      token: this.password.slice(i, +j + 1 || 9e9),\n      i,\n      j\n    };\n  },\n  // helper: considers whether a length-sequenceLength\n  // sequence ending at match m is better (fewer guesses)\n  // than previously encountered sequences, updating state if so.\n  update(match, sequenceLength) {\n    const k = match.j;\n    const estimatedMatch = estimateGuesses(match, this.password);\n    let pi = estimatedMatch.guesses;\n    if (sequenceLength > 1) {\n      // we're considering a length-sequenceLength sequence ending with match m:\n      // obtain the product term in the minimization function by multiplying m's guesses\n      // by the product of the length-(sequenceLength-1)\n      // sequence ending just before m, at m.i - 1.\n      pi *= this.optimal.pi[estimatedMatch.i - 1][sequenceLength - 1];\n    }\n    // calculate the minimization func\n    let g = utils.factorial(sequenceLength) * pi;\n    if (!this.excludeAdditive) {\n      g += MIN_GUESSES_BEFORE_GROWING_SEQUENCE ** (sequenceLength - 1);\n    }\n    // update state if new best.\n    // first see if any competing sequences covering this prefix,\n    // with sequenceLength or fewer matches,\n    // fare better than this sequence. if so, skip it and return.\n    let shouldSkip = false;\n    Object.keys(this.optimal.g[k]).forEach(competingPatternLength => {\n      const competingMetricMatch = this.optimal.g[k][competingPatternLength];\n      if (parseInt(competingPatternLength, 10) <= sequenceLength) {\n        if (competingMetricMatch <= g) {\n          shouldSkip = true;\n        }\n      }\n    });\n    if (!shouldSkip) {\n      // this sequence might be part of the final optimal sequence.\n      this.optimal.g[k][sequenceLength] = g;\n      this.optimal.m[k][sequenceLength] = estimatedMatch;\n      this.optimal.pi[k][sequenceLength] = pi;\n    }\n  },\n  // helper: evaluate bruteforce matches ending at passwordCharIndex.\n  bruteforceUpdate(passwordCharIndex) {\n    // see if a single bruteforce match spanning the passwordCharIndex-prefix is optimal.\n    let match = this.makeBruteforceMatch(0, passwordCharIndex);\n    this.update(match, 1);\n    for (let i = 1; i <= passwordCharIndex; i += 1) {\n      // generate passwordCharIndex bruteforce matches, spanning from (i=1, j=passwordCharIndex) up to (i=passwordCharIndex, j=passwordCharIndex).\n      // see if adding these new matches to any of the sequences in optimal[i-1]\n      // leads to new bests.\n      match = this.makeBruteforceMatch(i, passwordCharIndex);\n      const tmp = this.optimal.m[i - 1];\n      // eslint-disable-next-line no-loop-func\n      Object.keys(tmp).forEach(sequenceLength => {\n        const lastMatch = tmp[sequenceLength];\n        // corner: an optimal sequence will never have two adjacent bruteforce matches.\n        // it is strictly better to have a single bruteforce match spanning the same region:\n        // same contribution to the guess product with a lower length.\n        // --> safe to skip those cases.\n        if (lastMatch.pattern !== 'bruteforce') {\n          // try adding m to this length-sequenceLength sequence.\n          this.update(match, parseInt(sequenceLength, 10) + 1);\n        }\n      });\n    }\n  },\n  // helper: step backwards through optimal.m starting at the end,\n  // constructing the final optimal match sequence.\n  unwind(passwordLength) {\n    const optimalMatchSequence = [];\n    let k = passwordLength - 1;\n    // find the final best sequence length and score\n    let sequenceLength = 0;\n    // eslint-disable-next-line no-loss-of-precision\n    let g = 2e308;\n    const temp = this.optimal.g[k];\n    // safety check for empty passwords\n    if (temp) {\n      Object.keys(temp).forEach(candidateSequenceLength => {\n        const candidateMetricMatch = temp[candidateSequenceLength];\n        if (candidateMetricMatch < g) {\n          sequenceLength = parseInt(candidateSequenceLength, 10);\n          g = candidateMetricMatch;\n        }\n      });\n    }\n    while (k >= 0) {\n      const match = this.optimal.m[k][sequenceLength];\n      optimalMatchSequence.unshift(match);\n      k = match.i - 1;\n      sequenceLength -= 1;\n    }\n    return optimalMatchSequence;\n  }\n};\nvar scoring = {\n  // ------------------------------------------------------------------------------\n  // search --- most guessable match sequence -------------------------------------\n  // ------------------------------------------------------------------------------\n  //\n  // takes a sequence of overlapping matches, returns the non-overlapping sequence with\n  // minimum guesses. the following is a O(l_max * (n + m)) dynamic programming algorithm\n  // for a length-n password with m candidate matches. l_max is the maximum optimal\n  // sequence length spanning each prefix of the password. In practice it rarely exceeds 5 and the\n  // search terminates rapidly.\n  //\n  // the optimal \"minimum guesses\" sequence is here defined to be the sequence that\n  // minimizes the following function:\n  //\n  //    g = sequenceLength! * Product(m.guesses for m in sequence) + D^(sequenceLength - 1)\n  //\n  // where sequenceLength is the length of the sequence.\n  //\n  // the factorial term is the number of ways to order sequenceLength patterns.\n  //\n  // the D^(sequenceLength-1) term is another length penalty, roughly capturing the idea that an\n  // attacker will try lower-length sequences first before trying length-sequenceLength sequences.\n  //\n  // for example, consider a sequence that is date-repeat-dictionary.\n  //  - an attacker would need to try other date-repeat-dictionary combinations,\n  //    hence the product term.\n  //  - an attacker would need to try repeat-date-dictionary, dictionary-repeat-date,\n  //    ..., hence the factorial term.\n  //  - an attacker would also likely try length-1 (dictionary) and length-2 (dictionary-date)\n  //    sequences before length-3. assuming at minimum D guesses per pattern type,\n  //    D^(sequenceLength-1) approximates Sum(D^i for i in [1..sequenceLength-1]\n  //\n  // ------------------------------------------------------------------------------\n  mostGuessableMatchSequence(password, matches, excludeAdditive = false) {\n    scoringHelper.password = password;\n    scoringHelper.excludeAdditive = excludeAdditive;\n    const passwordLength = password.length;\n    // partition matches into sublists according to ending index j\n    let matchesByCoordinateJ = scoringHelper.fillArray(passwordLength, 'array');\n    matches.forEach(match => {\n      matchesByCoordinateJ[match.j].push(match);\n    });\n    // small detail: for deterministic output, sort each sublist by i.\n    matchesByCoordinateJ = matchesByCoordinateJ.map(match => match.sort((m1, m2) => m1.i - m2.i));\n    scoringHelper.optimal = {\n      // optimal.m[k][sequenceLength] holds final match in the best length-sequenceLength\n      // match sequence covering the\n      // password prefix up to k, inclusive.\n      // if there is no length-sequenceLength sequence that scores better (fewer guesses) than\n      // a shorter match sequence spanning the same prefix,\n      // optimal.m[k][sequenceLength] is undefined.\n      m: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the product term Prod(m.guesses for m in sequence).\n      // optimal.pi allows for fast (non-looping) updates to the minimization function.\n      pi: scoringHelper.fillArray(passwordLength, 'object'),\n      // same structure as optimal.m -- holds the overall metric.\n      g: scoringHelper.fillArray(passwordLength, 'object')\n    };\n    for (let k = 0; k < passwordLength; k += 1) {\n      matchesByCoordinateJ[k].forEach(match => {\n        if (match.i > 0) {\n          Object.keys(scoringHelper.optimal.m[match.i - 1]).forEach(sequenceLength => {\n            scoringHelper.update(match, parseInt(sequenceLength, 10) + 1);\n          });\n        } else {\n          scoringHelper.update(match, 1);\n        }\n      });\n      scoringHelper.bruteforceUpdate(k);\n    }\n    const optimalMatchSequence = scoringHelper.unwind(passwordLength);\n    const optimalSequenceLength = optimalMatchSequence.length;\n    const guesses = this.getGuesses(password, optimalSequenceLength);\n    return {\n      password,\n      guesses,\n      guessesLog10: utils.log10(guesses),\n      sequence: optimalMatchSequence\n    };\n  },\n  getGuesses(password, optimalSequenceLength) {\n    const passwordLength = password.length;\n    let guesses = 0;\n    if (password.length === 0) {\n      guesses = 1;\n    } else {\n      guesses = scoringHelper.optimal.g[passwordLength - 1][optimalSequenceLength];\n    }\n    return guesses;\n  }\n};\n\nexport { scoring as default };\n//# sourceMappingURL=index.esm.js.map\n","import scoring from '../../scoring/index.esm.js';\n\n/*\n *-------------------------------------------------------------------------------\n * repeats (aaa, abcabcabc) ------------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchRepeat {\n  // eslint-disable-next-line max-statements\n  match({\n    password,\n    omniMatch\n  }) {\n    const matches = [];\n    let lastIndex = 0;\n    while (lastIndex < password.length) {\n      const greedyMatch = this.getGreedyMatch(password, lastIndex);\n      const lazyMatch = this.getLazyMatch(password, lastIndex);\n      if (greedyMatch == null) {\n        break;\n      }\n      const {\n        match,\n        baseToken\n      } = this.setMatchToken(greedyMatch, lazyMatch);\n      if (match) {\n        const j = match.index + match[0].length - 1;\n        const baseGuesses = this.getBaseGuesses(baseToken, omniMatch);\n        matches.push(this.normalizeMatch(baseToken, j, match, baseGuesses));\n        lastIndex = j + 1;\n      }\n    }\n    const hasPromises = matches.some(match => {\n      return match instanceof Promise;\n    });\n    if (hasPromises) {\n      return Promise.all(matches);\n    }\n    return matches;\n  }\n  // eslint-disable-next-line max-params\n  normalizeMatch(baseToken, j, match, baseGuesses) {\n    const baseMatch = {\n      pattern: 'repeat',\n      i: match.index,\n      j,\n      token: match[0],\n      baseToken,\n      baseGuesses: 0,\n      repeatCount: match[0].length / baseToken.length\n    };\n    if (baseGuesses instanceof Promise) {\n      return baseGuesses.then(resolvedBaseGuesses => {\n        return {\n          ...baseMatch,\n          baseGuesses: resolvedBaseGuesses\n        };\n      });\n    }\n    return {\n      ...baseMatch,\n      baseGuesses\n    };\n  }\n  getGreedyMatch(password, lastIndex) {\n    const greedy = /(.+)\\1+/g;\n    greedy.lastIndex = lastIndex;\n    return greedy.exec(password);\n  }\n  getLazyMatch(password, lastIndex) {\n    const lazy = /(.+?)\\1+/g;\n    lazy.lastIndex = lastIndex;\n    return lazy.exec(password);\n  }\n  setMatchToken(greedyMatch, lazyMatch) {\n    const lazyAnchored = /^(.+?)\\1+$/;\n    let match;\n    let baseToken = '';\n    if (lazyMatch && greedyMatch[0].length > lazyMatch[0].length) {\n      // greedy beats lazy for 'aabaab'\n      // greedy: [aabaab, aab]\n      // lazy:   [aa,     a]\n      match = greedyMatch;\n      // greedy's repeated string might itself be repeated, eg.\n      // aabaab in aabaabaabaab.\n      // run an anchored lazy match on greedy's repeated string\n      // to find the shortest repeated string\n      const temp = lazyAnchored.exec(match[0]);\n      if (temp) {\n        baseToken = temp[1];\n      }\n    } else {\n      // lazy beats greedy for 'aaaaa'\n      // greedy: [aaaa,  aa]\n      // lazy:   [aaaaa, a]\n      match = lazyMatch;\n      if (match) {\n        baseToken = match[1];\n      }\n    }\n    return {\n      match,\n      baseToken\n    };\n  }\n  getBaseGuesses(baseToken, omniMatch) {\n    const matches = omniMatch.match(baseToken);\n    if (matches instanceof Promise) {\n      return matches.then(resolvedMatches => {\n        const baseAnalysis = scoring.mostGuessableMatchSequence(baseToken, resolvedMatches);\n        return baseAnalysis.guesses;\n      });\n    }\n    const baseAnalysis = scoring.mostGuessableMatchSequence(baseToken, matches);\n    return baseAnalysis.guesses;\n  }\n}\n\nexport { MatchRepeat as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { ALL_LOWER, ALL_UPPER, ALL_DIGIT } from '../../data/const.esm.js';\n\n/*\n *-------------------------------------------------------------------------------\n * sequences (abcdef) ------------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchSequence {\n  constructor() {\n    this.MAX_DELTA = 5;\n  }\n  // eslint-disable-next-line max-statements\n  match({\n    password\n  }) {\n    /*\n     * Identifies sequences by looking for repeated differences in unicode codepoint.\n     * this allows skipping, such as 9753, and also matches some extended unicode sequences\n     * such as Greek and Cyrillic alphabets.\n     *\n     * for example, consider the input 'abcdb975zy'\n     *\n     * password: a   b   c   d   b    9   7   5   z   y\n     * index:    0   1   2   3   4    5   6   7   8   9\n     * delta:      1   1   1  -2  -41  -2  -2  69   1\n     *\n     * expected result:\n     * [(i, j, delta), ...] = [(0, 3, 1), (5, 7, -2), (8, 9, 1)]\n     */\n    const result = [];\n    if (password.length === 1) {\n      return [];\n    }\n    let i = 0;\n    let lastDelta = null;\n    const passwordLength = password.length;\n    for (let k = 1; k < passwordLength; k += 1) {\n      const delta = password.charCodeAt(k) - password.charCodeAt(k - 1);\n      if (lastDelta == null) {\n        lastDelta = delta;\n      }\n      if (delta !== lastDelta) {\n        const j = k - 1;\n        this.update({\n          i,\n          j,\n          delta: lastDelta,\n          password,\n          result\n        });\n        i = j;\n        lastDelta = delta;\n      }\n    }\n    this.update({\n      i,\n      j: passwordLength - 1,\n      delta: lastDelta,\n      password,\n      result\n    });\n    return result;\n  }\n  update({\n    i,\n    j,\n    delta,\n    password,\n    result\n  }) {\n    if (j - i > 1 || Math.abs(delta) === 1) {\n      const absoluteDelta = Math.abs(delta);\n      if (absoluteDelta > 0 && absoluteDelta <= this.MAX_DELTA) {\n        const token = password.slice(i, +j + 1 || 9e9);\n        const {\n          sequenceName,\n          sequenceSpace\n        } = this.getSequence(token);\n        return result.push({\n          pattern: 'sequence',\n          i,\n          j,\n          token: password.slice(i, +j + 1 || 9e9),\n          sequenceName,\n          sequenceSpace,\n          ascending: delta > 0\n        });\n      }\n    }\n    return null;\n  }\n  getSequence(token) {\n    // TODO conservatively stick with roman alphabet size.\n    //  (this could be improved)\n    let sequenceName = 'unicode';\n    let sequenceSpace = 26;\n    if (ALL_LOWER.test(token)) {\n      sequenceName = 'lower';\n      sequenceSpace = 26;\n    } else if (ALL_UPPER.test(token)) {\n      sequenceName = 'upper';\n      sequenceSpace = 26;\n    } else if (ALL_DIGIT.test(token)) {\n      sequenceName = 'digits';\n      sequenceSpace = 10;\n    }\n    return {\n      sequenceName,\n      sequenceSpace\n    };\n  }\n}\n\nexport { MatchSequence as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { extend, sorted } from '../../helper.esm.js';\nimport { zxcvbnOptions } from '../../Options.esm.js';\n\n/*\n * ------------------------------------------------------------------------------\n * spatial match (qwerty/dvorak/keypad and so on) -----------------------------------------\n * ------------------------------------------------------------------------------\n */\nclass MatchSpatial {\n  constructor() {\n    this.SHIFTED_RX = /[~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?]/;\n  }\n  match({\n    password\n  }) {\n    const matches = [];\n    Object.keys(zxcvbnOptions.graphs).forEach(graphName => {\n      const graph = zxcvbnOptions.graphs[graphName];\n      extend(matches, this.helper(password, graph, graphName));\n    });\n    return sorted(matches);\n  }\n  checkIfShifted(graphName, password, index) {\n    if (!graphName.includes('keypad') &&\n    // initial character is shifted\n    this.SHIFTED_RX.test(password.charAt(index))) {\n      return 1;\n    }\n    return 0;\n  }\n  // eslint-disable-next-line complexity, max-statements\n  helper(password, graph, graphName) {\n    let shiftedCount;\n    const matches = [];\n    let i = 0;\n    const passwordLength = password.length;\n    while (i < passwordLength - 1) {\n      let j = i + 1;\n      let lastDirection = null;\n      let turns = 0;\n      shiftedCount = this.checkIfShifted(graphName, password, i);\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        const prevChar = password.charAt(j - 1);\n        const adjacents = graph[prevChar] || [];\n        let found = false;\n        let foundDirection = -1;\n        let curDirection = -1;\n        // consider growing pattern by one character if j hasn't gone over the edge.\n        if (j < passwordLength) {\n          const curChar = password.charAt(j);\n          const adjacentsLength = adjacents.length;\n          for (let k = 0; k < adjacentsLength; k += 1) {\n            const adjacent = adjacents[k];\n            curDirection += 1;\n            // eslint-disable-next-line max-depth\n            if (adjacent) {\n              const adjacentIndex = adjacent.indexOf(curChar);\n              // eslint-disable-next-line max-depth\n              if (adjacentIndex !== -1) {\n                found = true;\n                foundDirection = curDirection;\n                // eslint-disable-next-line max-depth\n                if (adjacentIndex === 1) {\n                  // # index 1 in the adjacency means the key is shifted,\n                  // # 0 means unshifted: A vs a, % vs 5, etc.\n                  // # for example, 'q' is adjacent to the entry '2@'.\n                  // # @ is shifted w/ index 1, 2 is unshifted.\n                  shiftedCount += 1;\n                }\n                // eslint-disable-next-line max-depth\n                if (lastDirection !== foundDirection) {\n                  // # adding a turn is correct even in the initial\n                  // case when last_direction is null:\n                  // # every spatial pattern starts with a turn.\n                  turns += 1;\n                  lastDirection = foundDirection;\n                }\n                break;\n              }\n            }\n          }\n        }\n        // if the current pattern continued, extend j and try to grow again\n        if (found) {\n          j += 1;\n          // otherwise push the pattern discovered so far, if any...\n        } else {\n          // don't consider length 1 or 2 chains.\n          if (j - i > 2) {\n            matches.push({\n              pattern: 'spatial',\n              i,\n              j: j - 1,\n              token: password.slice(i, j),\n              graph: graphName,\n              turns,\n              shiftedCount\n            });\n          }\n          // ...and then start a new search for the rest of the password.\n          i = j;\n          break;\n        }\n      }\n    }\n    return matches;\n  }\n}\n\nexport { MatchSpatial as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { SEPERATOR_CHARS } from '../../data/const.esm.js';\n\nconst separatorRegex = new RegExp(`[${SEPERATOR_CHARS.join('')}]`);\n/*\n *-------------------------------------------------------------------------------\n * separators (any semi-repeated special character) -----------------------------\n *-------------------------------------------------------------------------------\n */\nclass MatchSeparator {\n  static getMostUsedSeparatorChar(password) {\n    const mostUsedSeperators = [...password.split('').filter(c => separatorRegex.test(c)).reduce((memo, c) => {\n      const m = memo.get(c);\n      if (m) {\n        memo.set(c, m + 1);\n      } else {\n        memo.set(c, 1);\n      }\n      return memo;\n    }, new Map()).entries()].sort(([_a, a], [_b, b]) => b - a);\n    if (!mostUsedSeperators.length) return undefined;\n    const match = mostUsedSeperators[0];\n    // If the special character is only used once, don't treat it like a separator\n    if (match[1] < 2) return undefined;\n    return match[0];\n  }\n  static getSeparatorRegex(separator) {\n    return new RegExp(`([^${separator}\\n])(${separator})(?!${separator})`, 'g');\n    // negative lookbehind can be added again in a few years when it is more supported by the browsers (currently 2023)\n    // https://github.com/zxcvbn-ts/zxcvbn/issues/202\n    // return new RegExp(`(?<!${separator})(${separator})(?!${separator})`, 'g')\n  }\n  // eslint-disable-next-line max-statements\n  match({\n    password\n  }) {\n    const result = [];\n    if (password.length === 0) return result;\n    const mostUsedSpecial = MatchSeparator.getMostUsedSeparatorChar(password);\n    if (mostUsedSpecial === undefined) return result;\n    const isSeparator = MatchSeparator.getSeparatorRegex(mostUsedSpecial);\n    // eslint-disable-next-line no-restricted-syntax\n    for (const match of password.matchAll(isSeparator)) {\n      // eslint-disable-next-line no-continue\n      if (match.index === undefined) continue;\n      // add one to the index because we changed the regex from negative lookbehind to something simple.\n      // this simple approach uses the first character before the separater too but we only need the index of the separater\n      // https://github.com/zxcvbn-ts/zxcvbn/issues/202\n      const i = match.index + 1;\n      result.push({\n        pattern: 'separator',\n        token: mostUsedSpecial,\n        i,\n        j: i\n      });\n    }\n    return result;\n  }\n}\n\nexport { MatchSeparator as default };\n//# sourceMappingURL=matching.esm.js.map\n","import { extend, sorted } from './helper.esm.js';\nimport MatchDate from './matcher/date/matching.esm.js';\nimport MatchDictionary from './matcher/dictionary/matching.esm.js';\nimport MatchRegex from './matcher/regex/matching.esm.js';\nimport MatchRepeat from './matcher/repeat/matching.esm.js';\nimport MatchSequence from './matcher/sequence/matching.esm.js';\nimport MatchSpatial from './matcher/spatial/matching.esm.js';\nimport MatchSeparator from './matcher/separator/matching.esm.js';\nimport { zxcvbnOptions } from './Options.esm.js';\n\nclass Matching {\n  constructor() {\n    this.matchers = {\n      date: MatchDate,\n      dictionary: MatchDictionary,\n      regex: MatchRegex,\n      // @ts-ignore => TODO resolve this type issue. This is because it is possible to be async\n      repeat: MatchRepeat,\n      sequence: MatchSequence,\n      spatial: MatchSpatial,\n      separator: MatchSeparator\n    };\n  }\n  match(password) {\n    const matches = [];\n    const promises = [];\n    const matchers = [...Object.keys(this.matchers), ...Object.keys(zxcvbnOptions.matchers)];\n    matchers.forEach(key => {\n      if (!this.matchers[key] && !zxcvbnOptions.matchers[key]) {\n        return;\n      }\n      const Matcher = this.matchers[key] ? this.matchers[key] : zxcvbnOptions.matchers[key].Matching;\n      const usedMatcher = new Matcher();\n      const result = usedMatcher.match({\n        password,\n        omniMatch: this\n      });\n      if (result instanceof Promise) {\n        result.then(response => {\n          extend(matches, response);\n        });\n        promises.push(result);\n      } else {\n        extend(matches, result);\n      }\n    });\n    if (promises.length > 0) {\n      return new Promise((resolve, reject) => {\n        Promise.all(promises).then(() => {\n          resolve(sorted(matches));\n        }).catch(error => {\n          reject(error);\n        });\n      });\n    }\n    return sorted(matches);\n  }\n}\n\nexport { Matching as default };\n//# sourceMappingURL=Matching.esm.js.map\n","import { zxcvbnOptions } from './Options.esm.js';\n\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst MONTH = DAY * 31;\nconst YEAR = MONTH * 12;\nconst CENTURY = YEAR * 100;\nconst times = {\n  second: SECOND,\n  minute: MINUTE,\n  hour: HOUR,\n  day: DAY,\n  month: MONTH,\n  year: YEAR,\n  century: CENTURY\n};\n/*\n * -------------------------------------------------------------------------------\n *  Estimates time for an attacker ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass TimeEstimates {\n  translate(displayStr, value) {\n    let key = displayStr;\n    if (value !== undefined && value !== 1) {\n      key += 's';\n    }\n    const {\n      timeEstimation\n    } = zxcvbnOptions.translations;\n    return timeEstimation[key].replace('{base}', `${value}`);\n  }\n  estimateAttackTimes(guesses) {\n    const crackTimesSeconds = {\n      onlineThrottling100PerHour: guesses / (100 / 3600),\n      onlineNoThrottling10PerSecond: guesses / 10,\n      offlineSlowHashing1e4PerSecond: guesses / 1e4,\n      offlineFastHashing1e10PerSecond: guesses / 1e10\n    };\n    const crackTimesDisplay = {\n      onlineThrottling100PerHour: '',\n      onlineNoThrottling10PerSecond: '',\n      offlineSlowHashing1e4PerSecond: '',\n      offlineFastHashing1e10PerSecond: ''\n    };\n    Object.keys(crackTimesSeconds).forEach(scenario => {\n      const seconds = crackTimesSeconds[scenario];\n      crackTimesDisplay[scenario] = this.displayTime(seconds);\n    });\n    return {\n      crackTimesSeconds,\n      crackTimesDisplay,\n      score: this.guessesToScore(guesses)\n    };\n  }\n  guessesToScore(guesses) {\n    const DELTA = 5;\n    if (guesses < 1e3 + DELTA) {\n      // risky password: \"too guessable\"\n      return 0;\n    }\n    if (guesses < 1e6 + DELTA) {\n      // modest protection from throttled online attacks: \"very guessable\"\n      return 1;\n    }\n    if (guesses < 1e8 + DELTA) {\n      // modest protection from unthrottled online attacks: \"somewhat guessable\"\n      return 2;\n    }\n    if (guesses < 1e10 + DELTA) {\n      // modest protection from offline attacks: \"safely unguessable\"\n      // assuming a salted, slow hash function like bcrypt, scrypt, PBKDF2, argon, etc\n      return 3;\n    }\n    // strong protection from offline attacks under same scenario: \"very unguessable\"\n    return 4;\n  }\n  displayTime(seconds) {\n    let displayStr = 'centuries';\n    let base;\n    const timeKeys = Object.keys(times);\n    const foundIndex = timeKeys.findIndex(time => seconds < times[time]);\n    if (foundIndex > -1) {\n      displayStr = timeKeys[foundIndex - 1];\n      if (foundIndex !== 0) {\n        base = Math.round(seconds / times[displayStr]);\n      } else {\n        displayStr = 'ltSecond';\n      }\n    }\n    return this.translate(displayStr, base);\n  }\n}\n\nexport { TimeEstimates as default };\n//# sourceMappingURL=TimeEstimates.esm.js.map\n","var bruteforceMatcher = (() => {\n  return null;\n});\n\nexport { bruteforceMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import { zxcvbnOptions } from '../../Options.esm.js';\n\nvar dateMatcher = (() => {\n  return {\n    warning: zxcvbnOptions.translations.warnings.dates,\n    suggestions: [zxcvbnOptions.translations.suggestions.dates]\n  };\n});\n\nexport { dateMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import { zxcvbnOptions } from '../../Options.esm.js';\nimport { START_UPPER, ALL_UPPER_INVERTED } from '../../data/const.esm.js';\n\nconst getDictionaryWarningPassword = (match, isSoleMatch) => {\n  let warning = null;\n  if (isSoleMatch && !match.l33t && !match.reversed) {\n    if (match.rank <= 10) {\n      warning = zxcvbnOptions.translations.warnings.topTen;\n    } else if (match.rank <= 100) {\n      warning = zxcvbnOptions.translations.warnings.topHundred;\n    } else {\n      warning = zxcvbnOptions.translations.warnings.common;\n    }\n  } else if (match.guessesLog10 <= 4) {\n    warning = zxcvbnOptions.translations.warnings.similarToCommon;\n  }\n  return warning;\n};\nconst getDictionaryWarningWikipedia = (match, isSoleMatch) => {\n  let warning = null;\n  if (isSoleMatch) {\n    warning = zxcvbnOptions.translations.warnings.wordByItself;\n  }\n  return warning;\n};\nconst getDictionaryWarningNames = (match, isSoleMatch) => {\n  if (isSoleMatch) {\n    return zxcvbnOptions.translations.warnings.namesByThemselves;\n  }\n  return zxcvbnOptions.translations.warnings.commonNames;\n};\nconst getDictionaryWarning = (match, isSoleMatch) => {\n  let warning = null;\n  const dictName = match.dictionaryName;\n  const isAName = dictName === 'lastnames' || dictName.toLowerCase().includes('firstnames');\n  if (dictName === 'passwords') {\n    warning = getDictionaryWarningPassword(match, isSoleMatch);\n  } else if (dictName.includes('wikipedia')) {\n    warning = getDictionaryWarningWikipedia(match, isSoleMatch);\n  } else if (isAName) {\n    warning = getDictionaryWarningNames(match, isSoleMatch);\n  } else if (dictName === 'userInputs') {\n    warning = zxcvbnOptions.translations.warnings.userInputs;\n  }\n  return warning;\n};\nvar dictionaryMatcher = ((match, isSoleMatch) => {\n  const warning = getDictionaryWarning(match, isSoleMatch);\n  const suggestions = [];\n  const word = match.token;\n  if (word.match(START_UPPER)) {\n    suggestions.push(zxcvbnOptions.translations.suggestions.capitalization);\n  } else if (word.match(ALL_UPPER_INVERTED) && word.toLowerCase() !== word) {\n    suggestions.push(zxcvbnOptions.translations.suggestions.allUppercase);\n  }\n  if (match.reversed && match.token.length >= 4) {\n    suggestions.push(zxcvbnOptions.translations.suggestions.reverseWords);\n  }\n  if (match.l33t) {\n    suggestions.push(zxcvbnOptions.translations.suggestions.l33t);\n  }\n  return {\n    warning,\n    suggestions\n  };\n});\n\nexport { dictionaryMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import { zxcvbnOptions } from '../../Options.esm.js';\n\nvar regexMatcher = (match => {\n  if (match.regexName === 'recentYear') {\n    return {\n      warning: zxcvbnOptions.translations.warnings.recentYears,\n      suggestions: [zxcvbnOptions.translations.suggestions.recentYears, zxcvbnOptions.translations.suggestions.associatedYears]\n    };\n  }\n  return {\n    warning: null,\n    suggestions: []\n  };\n});\n\nexport { regexMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import { zxcvbnOptions } from '../../Options.esm.js';\n\nvar repeatMatcher = (match => {\n  let warning = zxcvbnOptions.translations.warnings.extendedRepeat;\n  if (match.baseToken.length === 1) {\n    warning = zxcvbnOptions.translations.warnings.simpleRepeat;\n  }\n  return {\n    warning,\n    suggestions: [zxcvbnOptions.translations.suggestions.repeated]\n  };\n});\n\nexport { repeatMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import { zxcvbnOptions } from '../../Options.esm.js';\n\nvar sequenceMatcher = (() => {\n  return {\n    warning: zxcvbnOptions.translations.warnings.sequences,\n    suggestions: [zxcvbnOptions.translations.suggestions.sequences]\n  };\n});\n\nexport { sequenceMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import { zxcvbnOptions } from '../../Options.esm.js';\n\nvar spatialMatcher = (match => {\n  let warning = zxcvbnOptions.translations.warnings.keyPattern;\n  if (match.turns === 1) {\n    warning = zxcvbnOptions.translations.warnings.straightRow;\n  }\n  return {\n    warning,\n    suggestions: [zxcvbnOptions.translations.suggestions.longerKeyboardPattern]\n  };\n});\n\nexport { spatialMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","var separatorMatcher = (() => {\n  // no suggestions\n  return null;\n});\n\nexport { separatorMatcher as default };\n//# sourceMappingURL=feedback.esm.js.map\n","import { zxcvbnOptions } from './Options.esm.js';\nimport bruteforceMatcher from './matcher/bruteforce/feedback.esm.js';\nimport dateMatcher from './matcher/date/feedback.esm.js';\nimport dictionaryMatcher from './matcher/dictionary/feedback.esm.js';\nimport regexMatcher from './matcher/regex/feedback.esm.js';\nimport repeatMatcher from './matcher/repeat/feedback.esm.js';\nimport sequenceMatcher from './matcher/sequence/feedback.esm.js';\nimport spatialMatcher from './matcher/spatial/feedback.esm.js';\nimport separatorMatcher from './matcher/separator/feedback.esm.js';\n\nconst defaultFeedback = {\n  warning: null,\n  suggestions: []\n};\n/*\n * -------------------------------------------------------------------------------\n *  Generate feedback ---------------------------------------------------------------\n * -------------------------------------------------------------------------------\n */\nclass Feedback {\n  constructor() {\n    this.matchers = {\n      bruteforce: bruteforceMatcher,\n      date: dateMatcher,\n      dictionary: dictionaryMatcher,\n      regex: regexMatcher,\n      repeat: repeatMatcher,\n      sequence: sequenceMatcher,\n      spatial: spatialMatcher,\n      separator: separatorMatcher\n    };\n    this.defaultFeedback = {\n      warning: null,\n      suggestions: []\n    };\n    this.setDefaultSuggestions();\n  }\n  setDefaultSuggestions() {\n    this.defaultFeedback.suggestions.push(zxcvbnOptions.translations.suggestions.useWords, zxcvbnOptions.translations.suggestions.noNeed);\n  }\n  getFeedback(score, sequence) {\n    if (sequence.length === 0) {\n      return this.defaultFeedback;\n    }\n    if (score > 2) {\n      return defaultFeedback;\n    }\n    const extraFeedback = zxcvbnOptions.translations.suggestions.anotherWord;\n    const longestMatch = this.getLongestMatch(sequence);\n    let feedback = this.getMatchFeedback(longestMatch, sequence.length === 1);\n    if (feedback !== null && feedback !== undefined) {\n      feedback.suggestions.unshift(extraFeedback);\n    } else {\n      feedback = {\n        warning: null,\n        suggestions: [extraFeedback]\n      };\n    }\n    return feedback;\n  }\n  getLongestMatch(sequence) {\n    let longestMatch = sequence[0];\n    const slicedSequence = sequence.slice(1);\n    slicedSequence.forEach(match => {\n      if (match.token.length > longestMatch.token.length) {\n        longestMatch = match;\n      }\n    });\n    return longestMatch;\n  }\n  getMatchFeedback(match, isSoleMatch) {\n    if (this.matchers[match.pattern]) {\n      return this.matchers[match.pattern](match, isSoleMatch);\n    }\n    if (zxcvbnOptions.matchers[match.pattern] && 'feedback' in zxcvbnOptions.matchers[match.pattern]) {\n      return zxcvbnOptions.matchers[match.pattern].feedback(match, isSoleMatch);\n    }\n    return defaultFeedback;\n  }\n}\n\nexport { Feedback as default };\n//# sourceMappingURL=Feedback.esm.js.map\n","import Matching from './Matching.esm.js';\nimport scoring from './scoring/index.esm.js';\nimport TimeEstimates from './TimeEstimates.esm.js';\nimport Feedback from './Feedback.esm.js';\nimport { zxcvbnOptions } from './Options.esm.js';\nexport { Options } from './Options.esm.js';\nexport { default as debounce } from './debounce.esm.js';\n\nconst time = () => new Date().getTime();\nconst createReturnValue = (resolvedMatches, password, start) => {\n  const feedback = new Feedback();\n  const timeEstimates = new TimeEstimates();\n  const matchSequence = scoring.mostGuessableMatchSequence(password, resolvedMatches);\n  const calcTime = time() - start;\n  const attackTimes = timeEstimates.estimateAttackTimes(matchSequence.guesses);\n  return {\n    calcTime,\n    ...matchSequence,\n    ...attackTimes,\n    feedback: feedback.getFeedback(attackTimes.score, matchSequence.sequence)\n  };\n};\nconst main = (password, userInputs) => {\n  if (userInputs) {\n    zxcvbnOptions.extendUserInputsDictionary(userInputs);\n  }\n  const matching = new Matching();\n  return matching.match(password);\n};\nconst zxcvbn = (password, userInputs) => {\n  const start = time();\n  const matches = main(password, userInputs);\n  if (matches instanceof Promise) {\n    throw new Error('You are using a Promised matcher, please use `zxcvbnAsync` for it.');\n  }\n  return createReturnValue(matches, password, start);\n};\nconst zxcvbnAsync = async (password, userInputs) => {\n  const usedPassword = password.substring(0, zxcvbnOptions.maxLength);\n  const start = time();\n  const matches = await main(usedPassword, userInputs);\n  return createReturnValue(matches, usedPassword, start);\n};\n\nexport { zxcvbn, zxcvbnAsync, zxcvbnOptions };\n//# sourceMappingURL=index.esm.js.map\n","<script setup lang=\"ts\">\nimport { ref, unref, computed, watch } from 'vue'\nimport { ElInput } from 'element-plus'\nimport { propTypes } from '@/utils/propTypes'\nimport { useConfigGlobal } from '@/hooks/web/useConfigGlobal'\nimport { zxcvbn } from '@zxcvbn-ts/core'\nimport type { ZxcvbnResult } from '@zxcvbn-ts/core'\nimport { useDesign } from '@/hooks/web/useDesign'\n\nconst { getPrefixCls } = useDesign()\n\nconst prefixCls = getPrefixCls('input-password')\n\nconst props = defineProps({\n  // 是否显示密码强度\n  strength: propTypes.bool.def(false),\n  modelValue: propTypes.string.def('')\n})\n\nwatch(\n  () => props.modelValue,\n  (val: string) => {\n    if (val === unref(valueRef)) return\n    valueRef.value = val\n  }\n)\n\nconst { configGlobal } = useConfigGlobal()\n\nconst emit = defineEmits(['update:modelValue'])\n\n// 设置input的type属性\nconst textType = ref<'password' | 'text'>('password')\n\n// 输入框的值\nconst valueRef = ref(props.modelValue)\n\n// 监听\nwatch(\n  () => valueRef.value,\n  (val: string) => {\n    emit('update:modelValue', val)\n  }\n)\n\n// 获取密码强度\nconst getPasswordStrength = computed(() => {\n  const value = unref(valueRef)\n  const zxcvbnRef = zxcvbn(unref(valueRef)) as ZxcvbnResult\n  return value ? zxcvbnRef.score : -1\n})\n</script>\n\n<template>\n  <div :class=\"[prefixCls, `${prefixCls}--${configGlobal?.size}`]\">\n    <ElInput v-bind=\"$attrs\" v-model=\"valueRef\" showPassword :type=\"textType\" />\n    <div\n      v-if=\"strength\"\n      :class=\"`${prefixCls}__bar`\"\n      class=\"relative h-6px mt-10px mb-6px mr-auto ml-auto\"\n    >\n      <div :class=\"`${prefixCls}__bar--fill`\" :data-score=\"getPasswordStrength\"></div>\n    </div>\n  </div>\n</template>\n\n<style lang=\"less\" scoped>\n@prefix-cls: ~'@{adminNamespace}-input-password';\n\n.@{prefix-cls} {\n  :deep(.@{elNamespace}-input__clear) {\n    margin-left: 5px;\n  }\n\n  &__bar {\n    background-color: var(--el-text-color-disabled);\n    border-radius: var(--el-border-radius-base);\n\n    &::before,\n    &::after {\n      position: absolute;\n      z-index: 10;\n      display: block;\n      width: 20%;\n      height: inherit;\n      background-color: transparent;\n      border-color: var(--el-color-white);\n      border-style: solid;\n      border-width: 0 5px;\n      content: '';\n    }\n\n    &::before {\n      left: 20%;\n    }\n\n    &::after {\n      right: 20%;\n    }\n\n    &--fill {\n      position: absolute;\n      width: 0;\n      height: inherit;\n      background-color: transparent;\n      border-radius: inherit;\n      transition:\n        width 0.5s ease-in-out,\n        background 0.25s;\n\n      &[data-score='0'] {\n        width: 20%;\n        background-color: var(--el-color-danger);\n      }\n\n      &[data-score='1'] {\n        width: 40%;\n        background-color: var(--el-color-danger);\n      }\n\n      &[data-score='2'] {\n        width: 60%;\n        background-color: var(--el-color-warning);\n      }\n\n      &[data-score='3'] {\n        width: 80%;\n        background-color: var(--el-color-success);\n      }\n\n      &[data-score='4'] {\n        width: 100%;\n        background-color: var(--el-color-success);\n      }\n    }\n  }\n\n  &--mini > &__bar {\n    border-radius: var(--el-border-radius-small);\n  }\n}\n</style>\n"],"names":["useConfigGlobal","inject","extend","listToExtend","list","sorted","matches","m1","m2","buildRankedDictionary","orderedList","result","counter","word","dateSplits","DATE_MAX_YEAR","DATE_MIN_YEAR","DATE_SPLITS","BRUTEFORCE_CARDINALITY","MIN_GUESSES_BEFORE_GROWING_SEQUENCE","MIN_SUBMATCH_GUESSES_SINGLE_CHAR","MIN_SUBMATCH_GUESSES_MULTI_CHAR","MIN_YEAR_SPACE","START_UPPER","END_UPPER","ALL_UPPER","ALL_UPPER_INVERTED","ALL_LOWER","ALL_LOWER_INVERTED","ONE_LOWER","ONE_UPPER","ALPHA_INVERTED","ALL_DIGIT","REFERENCE_YEAR","REGEXEN","SEPERATOR_CHARS","SEPERATOR_CHAR_COUNT","MatchDate","password","filteredMatches","maybeDateWithSeparator","i","j","token","regexMatch","dmy","maybeDateNoSeparator","metric","candidate","candidates","index","k","l","bestCandidate","minDistance","distance","match","isSubmatch","matchesLength","o","otherMatch","integers","over12","over31","under1","len1","int","possibleYearSplits","possibleYearSplitsLength","y","rest","dm","temp","data","day","month","year","peq","myers_32","a","b","n","m","lst","pv","mv","sc","eq","xv","myers_x","mhc","phc","hsize","vsize","start","vlen","pb","mb","xh","ph","mh","score","tmp","getUsedThreshold","entry","threshold","isPasswordToShort","isThresholdLongerThanPassword","findLevenshteinDistance","rankedDictionary","foundDistance","found","usedThreshold","foundEntryDistance","isInThreshold","l33tTable","translationKeys","TrieNode","parents","key","subs","firstChar","cur","c","child","l33tTableToTrieNode","triNode","letter","substitutions","substitution","Options","options","translations","valid","type","translationType","rankedDictionaries","rankedDictionariesMaxWorkSize","name","el","sanitizedInputs","input","inputType","dictionary","newList","matcher","zxcvbnOptions","MatchReverse","defaultMatch","passwordReversed","__spreadProps","__spreadValues","CleanPasswords","substr","limit","trieRoot","nodes","character","onlyFullSub","isFullSub","subIndex","changes","lastSubLetter","consecutiveSubCount","hasSubs","sub","newSubs","getCleanPasswords","getExtras","passwordWithSubs","iUnsubbed","value","change","usedChanges","jUnsubbed","filtered","subDisplay","t","MatchL33t","newMatch","l33tMatch","subbedPasswords","hasFullMatch","isFullSubstitution","subbedPassword","matchedDictionary","extras","alreadyIncluded","MatchDictionary","useLevenshtein","passwordLength","passwordLower","dictionaryName","rankedDict","longestDictionaryWordSize","searchWidth","searchEnd","usedPassword","isInDictionary","foundLevenshteinDistance","isFullPassword","isLevenshteinMatch","usedRankPassword","rank","MatchRegex","regexes","regex","utils","count","coEff","num","rval","bruteforceMatcher","guesses","__pow","minGuesses","dateMatcher","separator","getVariations","cleanedWord","wordArray","upperCaseCount","char","lowerCaseCount","variations","variationLength","uppercaseVariant","commonCases","commonCasesLength","countSubstring","string","substring","pos","getCounts","tokenLower","subbedCount","unsubbedCount","l33tVariant","l33t","p","possibilities","dictionaryMatcher","reversed","baseGuesses","uppercaseVariations","l33tVariations","reversedVariations","calculation","regexMatcher","regexName","charClassBases","repeatMatcher","repeatCount","sequenceMatcher","ascending","firstChr","calcAverageDegree","graph","average","neighbors","estimatePossiblePatterns","turns","startingPosition","averageDegree","tokenLength","possibleTurns","spatialMatcher","shiftedCount","unShiftedCount","shiftedVariations","separatorMatcher","getMinGuesses","matchers","getScoring","estimateGuesses","extraData","estimationResult","matchGuesses","scoringHelper","size","valueType","sequenceLength","estimatedMatch","pi","g","shouldSkip","competingPatternLength","competingMetricMatch","passwordCharIndex","optimalMatchSequence","candidateSequenceLength","candidateMetricMatch","scoring","excludeAdditive","matchesByCoordinateJ","optimalSequenceLength","MatchRepeat","omniMatch","lastIndex","greedyMatch","lazyMatch","baseToken","baseMatch","resolvedBaseGuesses","greedy","lazy","lazyAnchored","resolvedMatches","MatchSequence","lastDelta","delta","absoluteDelta","sequenceName","sequenceSpace","MatchSpatial","graphName","lastDirection","prevChar","adjacents","foundDirection","curDirection","curChar","adjacentsLength","adjacent","adjacentIndex","separatorRegex","MatchSeparator","mostUsedSeperators","memo","_a","_b","mostUsedSpecial","isSeparator","Matching","promises","Matcher","response","resolve","reject","error","SECOND","MINUTE","HOUR","DAY","MONTH","YEAR","CENTURY","times","TimeEstimates","displayStr","timeEstimation","crackTimesSeconds","crackTimesDisplay","scenario","seconds","base","timeKeys","foundIndex","time","getDictionaryWarningPassword","isSoleMatch","warning","getDictionaryWarningWikipedia","getDictionaryWarningNames","getDictionaryWarning","dictName","isAName","suggestions","defaultFeedback","Feedback","sequence","extraFeedback","longestMatch","feedback","createReturnValue","timeEstimates","matchSequence","calcTime","attackTimes","main","userInputs","zxcvbn","getPrefixCls","useDesign","prefixCls","props","__props","watch","val","unref","valueRef","configGlobal","emit","__emit","textType","ref","getPasswordStrength","computed","zxcvbnRef"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45]}